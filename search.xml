<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[「模板」替罪羊树]]></title>
    <url>%2Fpost%2F3d9e4e72.html</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#define mk make_pair#define fi first#define nd second#define pii pair&lt;int,int&gt;#define pb push_back#define sqr(x) ((x)*(x))using namespace std;typedef long long ll;inline ll read() &#123;ll x = 0; char ch = getchar(), w = 1;while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') w = -1;ch = getchar();&#125;while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0';ch = getchar();&#125;return x * w;&#125;void write(ll x) &#123;if(x &lt; 0) putchar('-'), x = -x;if(x &gt; 9) write(x / 10);putchar(x % 10 + '0');&#125;inline void writeln(ll x) &#123;write(x);puts("");&#125;const int N = 210000;int n;int rt;int ch[N][2];int s[N], c[N], tot, val[N], d[N];double alpha = 0.7; bool isb(int x) &#123; return s[ch[x][0]] &gt; s[x] * alpha || s[ch[x][1]] &gt; s[x] * alpha;&#125;void up(int x) &#123; s[x] = s[ch[x][0]] + s[ch[x][1]] + c[x];&#125;void dfs(int x, vector&lt;int&gt; &amp;v) &#123; if(ch[x][0])dfs(ch[x][0], v); if(!d[x]) v.pb(x); if(ch[x][1]) dfs(ch[x][1], v);&#125;int build(vector&lt;int&gt; &amp;v, int l, int r) &#123; if(l &gt; r) return 0; int mid = (l + r) &gt;&gt; 1; int x = v[mid]; ch[x][0] = ch[x][1] = 0; up(x); if(l &lt; mid) ch[x][0] = build(v, l, mid-1); if(r &gt; mid) ch[x][1] = build(v, mid + 1, r); up(x); return x;&#125;void rebuild(int &amp;jd) &#123; vector&lt;int&gt;v; dfs(jd, v); jd = build(v, 0, v.size()-1);&#125;void insert(int &amp;jd, int v) &#123; if(!jd) &#123; jd = ++tot; s[jd] = c[jd] = 1; val[jd] = v; return ; &#125; else &#123; ++s[jd]; if(v == val[jd]) &#123; ++c[jd]; d[jd] = 0; return; &#125; if(v &lt; val[jd]) insert(ch[jd][0], v); else insert(ch[jd][1], v); if(isb(jd)) rebuild(jd); &#125;&#125;const int inf = 1e9 + 7;pii getrak(int v) &#123; int now = rt, ans = 0; while(now) &#123; if(val[now] == v) return mk(ans + s[ch[now][0]] + 1, c[now]); //不是ans+1 if(v &lt;= val[now]) now = ch[now][0]; else ans += s[ch[now][0]] + c[now], now = ch[now][1]; &#125; return mk(ans, -inf);&#125; //返回a≤v 的位置 int getval(int v) &#123; int now = rt; while(1) &#123; if(v &gt; s[ch[now][0]] &amp;&amp; v &lt;= s[ch[now][0]] + c[now]) return val[now]; if(v &lt;= s[ch[now][0]]) now = ch[now][0]; else v -= s[ch[now][0]] + c[now], now = ch[now][1]; &#125; return 0;&#125;int getpre(int v) &#123; //不能像treap和slplay一样/*可能出现1-&gt; (2,3)然后1已经被删除，查询3的前驱就跪了 */ pii t = getrak(v); return getval(t.fi-(t.nd != -inf));&#125;int getnxt(int v) &#123; pii t = getrak(v); return getval(t.fi + (t.nd == -inf ? 1 : t.nd)); //getrak(v) + c[v] //前驱和后继是最容易错的 &#125;void Remove(int jd, int v) &#123; --s[jd]; if(val[jd] == v) &#123; if(c[jd] == 1) d[jd] = 1; --c[jd]; return; &#125; if(v &lt; val[jd]) Remove(ch[jd][0], v); else Remove(ch[jd][1], v);&#125;int main() &#123; n = read(); for(int i = 1; i &lt;= n; ++i) &#123; int op = read(), x = read(); if(op == 1) insert(rt,x); if(op == 2) Remove(rt, x); if(op == 3) writeln(getrak(x).fi); if(op == 4) writeln(getval(x)); if(op == 5) writeln(getpre(x)); if(op == 6) writeln(getnxt(x)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「hdu2966」In case of failure]]></title>
    <url>%2Fpost%2Fe981225f.html</url>
    <content type="text"><![CDATA[Problem Description To help their clients deal with faulty Cash Machines, the board of The Planar Bank has decided to stick a label expressing sincere regret and sorrow of the bank about the failure on every ATM. The very same label would gently ask the customer to calmly head to the nearest Machine (that should hopefully work fine). In order to do so, a list of two-dimensional locations of all n ATMs has been prepared, and your task is to find for each of them the one closest with respect to the Euclidean distance. Input The input contains several test cases. The very first line contains the number of cases t(t≤15)t (t \leq 15)t(t≤15) that follow. Each test cases begin with the number of Cash Machines n(2≤n≤105)n (2 \leq n \leq 10^5)n(2≤n≤105). Each of the next n lines contain the coordinates of one Cash Machine x,y(0≤x,y≤109)x,y (0 \leq x,y \leq 10^9)x,y(0≤x,y≤109) separated by a space. No two points in one test case will coincide. Output For each test case output nnn lines. iii-th of them should contain the squared distance between the iii-th ATM from the input and its nearest neighbour. Sample Input 1234567891011121314151617181920212223242526272821017 410 3424 198 2814 1245 527 3141 1142 4536 27150 01 22 33 24 08 47 46 36 18 011 012 213 114 215 0 Sample Output 1234567891011121314151617181920212223242520010014910014952975236097522251124552225 Source Central European Programming Contest 2008 Solution 题意就是要对输入的每一个点输出距离他最近的点的距离的最小值的平方。距离指欧几里得距离。 KdTree的模板题 查询的时候是查询到左右儿子矩阵的最近点的距离，不是四个角的距离。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;bitset&gt;#include&lt;cmath&gt;#define mk make_pair#define fi first#define nd second#define pii pair&lt;int,int&gt;#define pb push_back#define sqr(x) ((x)*(x))using namespace std;typedef long long ll;inline ll read() &#123;ll x = 0; char ch = getchar(), w = 1;while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') w = -1;ch = getchar();&#125;while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0';ch = getchar();&#125;return x * w;&#125;void write(ll x) &#123;if(x &lt; 0) putchar('-'), x = -x;if(x &gt; 9) write(x / 10);putchar(x % 10 + '0');&#125;inline void writeln(ll x) &#123;write(x);puts("");&#125;const int N = 1e5 + 6;int n;int rt;struct Point &#123; int x, y;&#125;a[N],b[N];bool cmpx(const Point &amp;x, const Point &amp;y) &#123; return x.x &lt; y.x;&#125;bool cmpy(const Point &amp;x, const Point &amp;y) &#123; return x.y &lt; y.y;&#125;int num;const ll inf = 1e9 + 7;int ch[N][2];struct KD &#123; Point p; ll x[2], y[2];&#125;t[N];void build(int &amp;o, int l, int r, int v) &#123; if(l &gt; r) return; o = ++num; int lt, rt, up,dn; lt = dn = inf; rt = up = -inf; for(int i = l; i &lt;= r; ++i) &#123; lt = min(lt, a[i].x); rt = max(rt, a[i].x); up = max(up, a[i].y); dn = min(dn, a[i].y); &#125; int mid = (l + r) &gt;&gt; 1; if(v) nth_element(a + l, a + mid, a + 1 + r, cmpy); else nth_element(a + l, a + mid, a + 1 + r, cmpx); t[o].p = a[mid]; t[o].x[0] = lt, t[o].x[1] = rt; t[o].y[0] = dn, t[o].y[1] = up; if(l &lt; mid) build(ch[o][0], l, mid-1, v ^ 1); if(r &gt; mid) build(ch[o][1], mid + 1, r, v ^ 1);&#125;ll ans;ll cal(ll x1, ll y1, ll x2, ll y2) &#123; return sqr(x1 - x2) + sqr(y1 - y2);&#125;ll getdi(Point &amp;x, int y) &#123; ll res = 0; if(t[y].x[0] &gt; x.x) res += sqr(x.x - t[y].x[0]); if(t[y].x[1] &lt; x.x) res += sqr(x.x - t[y].x[1]); if(t[y].y[0] &gt; x.y) res += sqr(x.y - t[y].y[0]); if(t[y].y[1] &lt; x.y) res += sqr(x.y - t[y].y[1]); return res;&#125;void query(int o, Point &amp;x) &#123; if(!o) return; ll tmp = cal(x.x, x.y, t[o].p.x, t[o].p.y); if(tmp &gt; 0 &amp;&amp; tmp &lt; ans) ans = tmp; if(!ch[o][0] &amp;&amp; !ch[o][1]) return; ll dl = 1e18 + 7, dr = 1e18 + 7; if(ch[o][0]) dl = getdi(x, ch[o][0]); if(ch[o][1]) dr = getdi(x, ch[o][1]); if(dl &lt; dr) &#123; //小优化 if(dl &lt; ans) query(ch[o][0], x); if(dr &lt; ans) query(ch[o][1], x); &#125; else &#123; if(dr &lt; ans) query(ch[o][1], x); if(dl &lt; ans) query(ch[o][0], x); &#125;&#125;int main() &#123; int T = read(); while(T--) &#123; n = read(); num = 0; for(int i = 1; i &lt;= n; ++i) a[i].x = read(), a[i].y = read(), b[i] = a[i]; build(rt, 1, n, 0); for(int i = 1; i &lt;= n; ++i) &#123; ans = 1e18+7; query(1, b[i]); writeln(ans); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>Kdtree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ1857」[Scoi2010]传送带]]></title>
    <url>%2Fpost%2Fff5150c5.html</url>
    <content type="text"><![CDATA[Description 在一个222维平面上有两条传送带，每一条传送带可以看成是一条线段。两条传送带分别为线段ABABAB和线段CDCDCD。lxhgww在ABABAB上的移动速度为PPP，在CDCDCD上的移动速度为QQQ，在平面上的移动速度RRR。现在lxhgww想从AAA点走到DDD点，他想知道最少需要走多长时间 Input 输入数据第一行是444个整数，表示AAA和BBB的坐标，分别为AxA_xAx​，AyA_yAy​，BxB_xBx​，ByB_yBy​ 第二行是444个整数，表示CCC和DDD的坐标，分别为Cx，Cy，Dx，Dy 第三行是333个整数，分别是PPP，QQQ，RRR Output 输出数据为一行，表示lxhgww从AAA点走到DDD点的最短时间，保留到小数点后222位 Sample Input 1230 0 0 100100 0 100 1002 2 1 Sample 1136.60 HINT 对于100%100\%100%的数据，1≤Ax,Ay,Bx,By,Cx,Cy,Dx,Dy≤10001\leq A_x,A_y,B_x,B_y,C_x,C_y,D_x,D_y\leq 10001≤Ax​,Ay​,Bx​,By​,Cx​,Cy​,Dx​,Dy​≤1000 1≤P,Q,R≤101\leq P,Q,R\leq101≤P,Q,R≤10 Solution 假设在线段ABABAB走的距离是x0x_0x0​，线段CDCDCD走的距离是x1x_1x1​。 可以求出三段线段的长度然后计算时间。长度用三角函数求，注意d=0d=0d=0的情况。 三分套三房也行，粒子群算法好写多了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;cmath&gt;#include&lt;bitset&gt;#define mk make_pair#define fi first#define sqr(x) ((x)*(x))#define nd second#define pii pair&lt;int,int&gt;#define pb push_back#define sqr(x) ((x)*(x))using namespace std;typedef long long ll;inline ll read() &#123;ll x = 0; char ch = getchar(), w = 1;while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') w = -1;ch = getchar();&#125;while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0';ch = getchar();&#125;return x * w;&#125;void write(ll x) &#123;if(x &lt; 0) putchar('-'), x = -x;if(x &gt; 9) write(x / 10);putchar(x % 10 + '0');&#125;inline void writeln(ll x) &#123;write(x);puts("");&#125;struct Point &#123; double x, y;&#125;a[4];const int N = 210;struct Linz &#123; double x[2], y, v[2], mx[2], my;&#125;p[N],g;double randd() &#123; return (double) rand() / RAND_MAX;&#125;double dist(double x1, double y1, double x2, double y2) &#123; return sqrt(sqr(x1 - x2) + sqr(y1 - y2));&#125;const int T = 20;double P, Q, R;double d[2];double tx1,tx2,ty1,ty2;double cal(Linz p) &#123; double t1 = p.x[0] / P ; double t2 = p.x[1] / Q; return t1 + t2 + dist(a[0].x + p.x[0] * tx1, a[0].y + p.x[0] * ty1, a[3].x - p.x[1] * tx2, a[3].y - p.x[1] * ty2) / R;&#125;void init() &#123; d[0] =dist(a[0].x, a[0].y, a[1].x,a[1].y); d[1] = dist(a[2].x,a[2].y, a[3].x,a[3].y); if(fabs(d[0]) &gt; 1e-8) &#123; tx1 = (a[1].x - a[0].x) / d[0]; ty1 = (a[1].y - a[0].y) / d[0]; &#125; if(fabs(d[1]) &gt; 1e-8) &#123; tx2 = (a[3].x - a[2].x) / d[1]; ty2 = (a[3].y - a[2].y) / d[1]; &#125; g.my = 1e99; for(int i = 1; i &lt;= T; ++i) &#123; p[i].mx[0] = p[i].x[0] = randd() * d[0]; p[i].mx[1] = p[i].x[1] = randd() * d[1]; p[i].my = p[i].y = cal(p[i]); if(p[i].my &lt; g.my) g = p[i]; &#125;&#125;void run() &#123; for(int i = 1; i &lt;= T; ++i) &#123; for(int j = 0; j &lt; 2; ++j) &#123; p[i].v[j] = p[i].v[j] * 0.4 + (p[i].mx[j] - p[i].x[j]) * randd() * 2+ (g.mx[j] - p[i].x[j]) * randd() * 2; if(p[i].v[j]&gt;d[j]) p[i].v[j] = d[j]; p[i].x[j] += p[i].v[j]; if(p[i].x[j] &lt; 0) p[i].x[j] = 0, p[i].v[j] = -p[i].v[j]; if(p[i].x[j] &gt; d[j]) p[i].x[j] = d[j], p[i].v[j] = -p[i].v[j]; &#125; p[i].y = cal(p[i]); if(p[i].y &lt; p[i].my) &#123; p[i].my = p[i].y; for(int j = 0; j &lt; 2; ++j) p[i].mx[j] = p[i].x[j]; &#125; &#125; for(int i = 1; i &lt;= T; ++i) if(g.my &gt; p[i].my) g = p[i];&#125;int main() &#123; for(int i = 0; i &lt; 4; ++i) scanf("%lf%lf",&amp;a[i].x, &amp;a[i].y); scanf("%lf%lf%lf",&amp;P, &amp;Q,&amp;R); init(); for(int i = 1; i &lt;= 100; ++i) run(); printf("%.2lf", g.my); return 0;&#125;]]></content>
      <categories>
        <category>最优化</category>
      </categories>
      <tags>
        <tag>粒子群</tag>
        <tag>三分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ4004」[JLOI2015]装备购买]]></title>
    <url>%2Fpost%2Ff52adfb3.html</url>
    <content type="text"><![CDATA[Description 脸哥最近在玩一款神奇的游戏，这个游戏里有 nnn 件装备，每件装备有 mmm 个属性，用向量 zi=(a1,…,aj,…,am)\mathbf{z_i}=(a_1, \ldots ,a_j, \ldots , a_m)zi​=(a1​,…,aj​,…,am​) 表示 (1≤i≤n, 1≤j≤m1 \leq i \leq n, \ 1 \leq j \leq m1≤i≤n, 1≤j≤m)，每个装备需要花费 cic_ici​，现在脸哥想买一些装备，但是脸哥很穷，所以总是盘算着怎样才能花尽量少的钱买尽量多的装备。对于脸哥来说，如果一件装备的属性能用购买的其他装备组合出（也就是说脸哥可以利用手上的这些装备组合出这件装备的效果），那么这件装备就没有买的必要了 严格的定义是，如果脸哥买了 zi1,…,zip\mathbf{z_{i_1}}, \ldots , \mathbf{z_{i_p}}zi1​​,…,zip​​这 ppp 件装备，那么对于任意待决定的 zh\mathbf{z_h}zh​，不存在 b1,…,bpb_1, \ldots ,b_pb1​,…,bp​使得 b1zi1+…+bpzip=zhb_1\mathbf{z_{i_1}} + \ldots + b_p\mathbf{z_{i_p}} = \mathbf{z_h}b1​zi1​​+…+bp​zip​​=zh​ （bib_ibi​均是实数），那么脸哥就会买 zh\mathbf{z_h}zh​，否则 zh\mathbf{z_h}zh​ 对脸哥就是无用的了，自然不必购买。 举个例子，z1=(1,2,3), z2=(3,4,5), zh=(2,3,4), b1=12, b2=12\mathbf{z_1}=(1, 2, 3), \ \mathbf{z_2}=(3, 4, 5), \ \mathbf{z_h}=(2, 3, 4), \ b_1 =\frac{1}{2}, \ b_2 =\frac{1}{2}z1​=(1,2,3), z2​=(3,4,5), zh​=(2,3,4), b1​=21​, b2​=21​，就有 b1z1+b2z2=zhb_1\mathbf{z_1} + b_2\mathbf{z_2} = \mathbf{z_h}b1​z1​+b2​z2​=zh​ ，那么如果脸哥买了 z1\mathbf{z_1}z1​和 z2\mathbf{z_2}z2​ 就不会再买 zh\mathbf{z_h}zh​了。 脸哥想要在买下最多数量的装备的情况下花最少的钱，你能帮他算一下吗？ Input 第一行两个数 nnn;mmm。接下来 nnn 行，每行 mmm 个数，其中第 iii 行描述装备 iii 的各项属性值。接下来一行 nnn 个数， 其中 cic_ici​ 表示购买第 iii 件装备的花费。 Output 一行两个数，第一个数表示能够购买的最多装备数量，第二个数表示在购买最多数量的装备的情况下的最小花费 Sample Input 123453 31 2 33 4 52 3 41 1 2 Sample Output 12 2 HINT 如题目中描述，选择装备 111 装备 222，装备 111 装备 333，装备 222 装备 333 均可，但选择装备 111 和装备 222 的花费最小，为 222。 对于 100%100\%100% 的数据, 1≤n,m≤5001 \leq n,m \leq 5001≤n,m≤500; 0≤aj≤10000 \leq a_j \leq 10000≤aj​≤1000。 Solution 每一个列的值，只能由一个行向量控制。 明白了这一点加上去网上查题解就能理解了。 精度要10−510^{-5}10−5才能过。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;cmath&gt;#include&lt;bitset&gt;#define mk make_pair#define fi first#define nd second#define pii pair&lt;int,int&gt;#define pb push_back#define sqr(x) ((x)*(x))#define eps 1e-5using namespace std;typedef long long ll;inline ll read() &#123;ll x = 0; char ch = getchar(), w = 1;while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') w = -1;ch = getchar();&#125;while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0';ch = getchar();&#125;return x * w;&#125;void write(ll x) &#123;if(x &lt; 0) putchar('-'), x = -x;if(x &gt; 9) write(x / 10);putchar(x % 10 + '0');&#125;inline void writeln(ll x) &#123;write(x);puts("");&#125;const int N = 610;int n, m;double a[N][N], c[N];int r[N], p[N];bool cmp(int x, int y) &#123; return c[x] &lt; c[y];&#125;int main() &#123; n = read(), m = read(); for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) scanf("%lf", &amp;a[i][j]); for(int i = 1; i &lt;= n; ++i) scanf("%lf", &amp;c[i]), r[i] = i; sort(r +1, r +1 + n, cmp); double ans = 0; int cnt = 0; for(int i = 1; i &lt;= n; ++i) for(int j = 1; j &lt;= m; ++j) if(fabs(a[r[i]][j]) &gt;= eps) &#123; if(!p[j]) &#123; ++cnt; ans += c[r[i]]; p[j] = r[i]; break; &#125; else &#123; double t = a[r[i]][j] / a[p[j]][j]; for(int k = j; k &lt;= m; ++k) a[r[i]][k] -= t * a[p[j]][k]; &#125; &#125; printf("%d %d\n", cnt, (int)ans); return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>高斯消元</tag>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ2125」最短路]]></title>
    <url>%2Fpost%2Fa15ed3c3.html</url>
    <content type="text"><![CDATA[Description 给一个NNN个点MMM条边的连通无向图，满足每条边最多属于一个环，有QQQ组询问，每次询问两点之间的最短路径。 Input 输入的第一行包含三个整数，分别表示NNN和MMM和QQQ 下接MMM行，每行三个整数vvv，uuu，www表示一条无向边v−uv-uv−u，长度为www 最后QQQ行，每行两个整数vvv，uuu表示一组询问 Output 输出QQQ行，每行一个整数表示询问的答案 Sample Input 123456789101112139 10 21 2 11 4 13 4 12 3 13 7 17 8 27 9 21 5 31 6 45 6 11 95 7 Sample Output 1256 HINT 对于100%100\%100%的数据，N≤10000N\leq 10000N≤10000，Q≤10000Q\leq 10000Q≤10000。 Solution]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>圆方树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ2653」middle]]></title>
    <url>%2Fpost%2Fa4ac2e13.html</url>
    <content type="text"><![CDATA[Description 数组sss左端点在[a,b][a,b][a,b]之间,右端点在[c,d][c,d][c,d]之间的所有子串中，最大的中位数。长度为nnn的数组bbb的中位数定义为b[⌈n2⌉]b[\lceil\frac{n}{2}\rceil]b[⌈2n​⌉] 其中a&lt;b&lt;c&lt;da&lt;b&lt;c&lt;da&lt;b&lt;c&lt;d。位置也从000开始标号。 Input 第一行序列长度nnn。接下来n行按顺序给出a中的数。 接下来一行QQQ。然后QQQ行每行a,b,c,da,b,c,da,b,c,d，我们令上个询问的答案是 x(如果这是第一个询问则x=0)。 令数组q={(a+x)%n,(b+x)%n,(c+x)%n,(d+x)%n}q=\{(a+x)\%n,(b+x)\%n,(c+x)\%n,(d+x)\%n\}q={(a+x)%n,(b+x)%n,(c+x)%n,(d+x)%n}。 将qqq从小到大排序之后，令真正的 要询问的a=q[0]a=q[0]a=q[0],b=q[1]b=q[1]b=q[1],c=q[2]c=q[2]c=q[2],d=q[3]d=q[3]d=q[3]。 输入保证满足条件。 第一行所谓“排过序”指的是从小到大排序！ n≤20000,Q≤25000n\leq 20000,Q\leq 25000n≤20000,Q≤25000 Output QQQ行依次给出询问的答案。 Sample Input 1234567891051703377852714510442243028096905631320645232133 1 0 22 3 1 43 1 4 Sample Output 123271451044271451044969056313 Solution 二分答案xxx 令ai=1a_i=1ai​=1若ai≥xai\ge xai≥x否则ai=−1ai=-1ai=−1 问题转变成sum[b+1,c−1]+sum[l,b]+sum[d,r]sum[b + 1,c - 1]+sum[l,b]+sum[d,r]sum[b+1,c−1]+sum[l,b]+sum[d,r]最大值，其中l∈[a,b],r∈[c,d]l\in[a,b],r\in[c,d]l∈[a,b],r∈[c,d] 对于每一种权值建立线段树，每个节点统计最大左边和最大右边以及区间的aia_iai​和。 rt[i−1]rt[i-1]rt[i−1]转移到rt[i]rt[i]rt[i] 显然就是所有ai=Vi−1a_i=V_i-1ai​=Vi​−1的位置都变成−1-1−1 但要注意，比如{2,3,3,3,3}\{2,3,3,3,3\}{2,3,3,3,3}在插入的时候要一段段插入。 xxx先插入{2}\{2\}{2}，再插入{3,3,3,3}\{3,3,3,3\}{3,3,3,3}。 代码里有两种一段段插入的方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#define mk make_pair#define fi first#define nd second#define pii pair&lt;int,int&gt;#define pb push_back#define sqr(x) ((x)*(x))using namespace std;typedef long long ll;inline ll read() &#123;ll x = 0; char ch = getchar(), w = 1;while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') w = -1;ch = getchar();&#125;while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0';ch = getchar();&#125;return x * w;&#125;void write(ll x) &#123;if(x &lt; 0) putchar('-'), x = -x;if(x &gt; 9) write(x / 10);putchar(x % 10 + '0');&#125;inline void writeln(ll x) &#123;write(x);puts("");&#125;const int N = 41000;int n;struct Node &#123; int v, i; bool operator &lt; (const Node &amp;rhs) const &#123; return v &lt; rhs.v; &#125;&#125;a[N];int b[N], tot,rt[N];struct Tree &#123; int l, r, lm, rm, s;&#125;t[N * 32];void up(int o) &#123; t[o].lm = max(t[t[o].l].lm, t[t[o].l].s + t[t[o].r].lm); t[o].rm = max(t[t[o].r].rm, t[t[o].r].s + t[t[o].l].rm); t[o].s = t[t[o].l].s + t[t[o].r].s;&#125;void build(int &amp;o, int L, int R) &#123; o = ++tot; if(L == R) &#123; t[o].lm = t[o].rm = t[o].s = 1; return; &#125; int mid = (L + R) &gt;&gt; 1; if(L &lt;= mid) build(t[o].l, L, mid); if(R &gt; mid) build(t[o].r, mid + 1, R); up(o);&#125;void insert(int pre, int &amp;o, int L, int R, int x) &#123; o = ++tot; t[o] = t[pre]; if(L == R) &#123; t[o].lm = t[o].rm = t[o].s = -1; return; &#125; int mid = (L + R) &gt;&gt; 1; if(x &lt;= mid)insert(t[pre].l, t[o].l, L, mid, x); else insert(t[pre].r, t[o].r, mid + 1, R, x); up(o);&#125;Tree query(int o, int L, int R, int l, int r) &#123; if(!o || l &gt; r) return (Tree)&#123;0,0,0,0,0&#125;; if(l &lt;= L &amp;&amp; r &gt;= R) return t[o]; int mid = (L + R) &gt;&gt; 1; if(r &lt;= mid) return query(t[o].l, L, mid, l, r); if(l &gt; mid) return query(t[o].r, mid + 1, R, l, r); Tree x = query(t[o].l, L, mid, l, r); Tree y = query(t[o].r, mid + 1, R, l, r); Tree z; z.s = x.s + y.s; z.lm = max(x.lm, x.s + y.lm); z.rm = max(y.rm, y.s + x.rm); return z;&#125;int get(int t, int *q) &#123; Tree x = query(rt[t], 1, n, q[1], q[2]); Tree y = query(rt[t], 1, n, q[0], q[1] - 1); Tree z = query(rt[t], 1, n, q[2] + 1, q[3]); return x.s + max(y.rm, 0) + max(z.lm,0);&#125;vector&lt;int&gt;c[N];int main() &#123; n = read(); for(int i = 1 ; i &lt;= n; ++i) a[i].v = read(), a[i].i = i, b[i] = a[i].v; *b = n; sort(b + 1, b + 1 + *b); *b = unique(b + 1, b + 1 + *b) - b - 1; for(int i = 1; i &lt;= n; ++i) a[i].v = lower_bound(b + 1, b + 1 + *b, a[i].v) - b, c[a[i].v].pb(i); sort(a + 1, a + 1 + n); build(rt[0], 1, n); a[n + 1].v = 1e9 + 2333; int p = n + 1;/* for(int i = 1; i &lt;= n; ++i) if(a[i].v != a[i - 1].v) &#123; //坑点啊 rt[a[i].v] = rt[a[i].v - 1]; while(p &lt; i) insert(rt[a[i].v], rt[a[i].v], 1, n, a[p].i), ++p; p = n + 1; if(a[p].v != a[i].v) p = i; &#125;*/ /* for(int i = 1; i &lt;= n; ++i) if(a[i].v != a[i - 1].v) &#123; if(i &gt; 1)insert(rt[a[i].v - 1], rt[a[i].v], 1, n, a[i - 1].i); // a[i - 1].i会等于1 else rt[a[i].v] = rt[a[i].v - 1]; while(p &lt; i - 1) insert(rt[a[i].v], rt[a[i].v], 1, n, a[p].i), ++p; p = i; &#125;*/ for(int i = 1; i &lt;= *b; ++i) &#123; //尽量想到去用vector rt[i] = rt[i - 1]; for(int j = c[i - 1].size() - 1;~j;--j) insert(rt[i], rt[i], 1, n, c[i-1][j]); &#125; int Q = read(); int q[4], ans = 0; while(Q--) &#123; for(int i = 0; i &lt; 4; ++i) q[i] = (read() + ans) % n + 1; sort(q, q + 4); int r = *b + 1, l = 1; while(r - l &gt; 1) &#123; int mid = (l + r) &gt;&gt; 1; if(get(mid, q) &gt;= 0) l = mid; else r = mid; &#125; writeln(ans = b[l]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>好题</category>
      </categories>
      <tags>
        <tag>主席树</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ1061」[Noi2008]志愿者招募]]></title>
    <url>%2Fpost%2Fb8495a27.html</url>
    <content type="text"><![CDATA[Description 第iii天至少需要AiA_iAi​个人在工作，每种人可以从sis_isi​工作到tit_iti​，并且会花费cic_ici​的代价。 问最少的花费满足可以条件。 Input 第一行包含两个整数NNN, MMM，表示完成项目的天数和可以招募的志愿者的种类。 接下来的一行中包含NNN个非负 整数，表示每天至少需要的志愿者人数。 接下来的MMM行中每行包含三个整数SiS_iSi​, TiT_iTi​, CiC_iCi​，含义如上文所述。为了 方便起见，我们可以认为每类志愿者的数量都是无限多的。 Output 仅包含一个整数，表示你所设计的最优方案的总费用。 Sample Input 123453 32 3 41 2 22 3 53 3 2 Sample Output 114 HINT 1≤N≤10001 \leq N \leq 10001≤N≤1000，1≤N1 \leq N1≤N，MMM ≤10000\leq 10000≤10000，题目中其他所涉及的数据均不超过231−12^{31}-1231−1。 Solution 流量平衡 X1−Y1=A1X_1-Y_1=A_1X1​−Y1​=A1​ X1+X2−Y2=A2X_1+X_2-Y_2=A_2X1​+X2​−Y2​=A2​ X2+X3−Y3=A3X_2+X_3-Y_3=A_3X2​+X3​−Y3​=A3​ 得到 A1−A0=X1−Y1A_1-A_0=X_1-Y_1A1​−A0​=X1​−Y1​ A2−A1=X2−Y2+Y1A_2-A_1=X_2-Y_2+Y_1A2​−A1​=X2​−Y2​+Y1​ A3−A2=X3−Y3+Y2−X1A_3-A_2=X_3-Y_3+Y_2-X_1A3​−A2​=X3​−Y3​+Y2​−X1​ At−A3=Y3−X2−X3A_t-A_3=Y_3-X_2-X_3At​−A3​=Y3​−X2​−X3​ 只要满足了这样的流量平衡，那么只要把一个个方程加回来就可以得到最上面的条件方程。 按照等式来构造网络流就行了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;bitset&gt;#define mk make_pair#define fi first#define nd second#define pii pair&lt;int,int&gt;#define pb push_back#define sqr(x) ((x)*(x))using namespace std;typedef long long ll;inline ll read() &#123;ll x = 0; char ch = getchar(), w = 1;while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') w = -1;ch = getchar();&#125;while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0';ch = getchar();&#125;return x * w;&#125;void write(ll x) &#123;if(x &lt; 0) putchar('-'), x = -x;if(x &gt; 9) write(x / 10);putchar(x % 10 + '0');&#125;inline void writeln(ll x) &#123;write(x);puts("");&#125;const int N = 3100, M = 3100 * 5 * 2;int n, m;const int inf = 1e8;struct Edge &#123; int u, v, c, f, nxt;&#125;e[M];int s, t;bool v[N];int d[N], head[N], en,pre[N], inc[N];void addedge(int x, int y, int c, int f) &#123; e[++en].u = x, e[en].v = y, e[en].nxt = head[x], head[x] = en, e[en].c = c, e[en].f = f; e[++en].u = y, e[en].v = x, e[en].nxt = head[y], head[y] = en, e[en].c = -c, e[en].f = 0;&#125;bool spfa() &#123; queue&lt;int&gt;q; memset(v, 0, sizeof v); memset(inc, 0x3f, sizeof inc); memset(d, 0x3f, sizeof d); d[s] = 0; q.push(s); while(!q.empty()) &#123; int x = q.front(); q.pop(); v[x] = 0; for(int i = head[x]; i; i = e[i].nxt) if(e[i].f)&#123; int y = e[i].v; if(d[y] &gt; d[x] + e[i].c) &#123; d[y] = d[x] + e[i].c; inc[y] = min(inc[x], e[i].f); pre[y] = i; if(!v[y]) v[y] = 1, q.push(y); &#125; &#125; &#125; return d[t] != 0x3f3f3f3f;&#125;ll maxflow() &#123; ll k = 0; while(spfa()) &#123; int x = t; ll res = 0; while(x != s) res += e[pre[x]].c, x = e[pre[x]].u; k += res * inc[t]; x = t; while(x != s) e[pre[x]].f -= inc[t], e[pre[x] ^ 1].f += inc[t],x = e[pre[x]].u; &#125; return k;&#125;int a[N], T[N];int main() &#123; en = 1; n = read(), m = read(); t = n + 2, s = n + 3; for(int i = 1; i &lt;= n; ++i) a[i] = read(); for(int i = 1; i &lt;= m; ++i) &#123; int x = read(), y = read(), c = read(); addedge(y + 1, x, c, inf); &#125; for(int i = 1; i &lt; n + 1; ++i) addedge(i, i + 1, 0, inf); for(int i = 1; i &lt;= n + 1; ++i) &#123; int d = a[i] - a[i - 1]; if(d &gt; 0) addedge(i, t, 0, d); else addedge(s, i, 0, -d); &#125; writeln(maxflow()); return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>有上下界网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pólya定理学习笔记]]></title>
    <url>%2Fpost%2F393dafff.html</url>
    <content type="text"><![CDATA[定义 置换群 置换群的元素是置换，运算是置换的连接。 置换群是置换的一个集合。 置换一般形式是 (a1b1a2b2a3b3a4b4)\left(\begin{array}{c}a_1\\ b_1\end{array} \begin{array}{c}a_2\\ b_2\end{array} \begin{array}{c}a_3\\ b_3\end{array} \begin{array}{c}a_4\\ b_4\end{array} \right)(a1​b1​​a2​b2​​a3​b3​​a4​b4​​) 其中aaa、bbb分别是1→n1\to n1→n的一个排列。 每一列表示位置为aia_iai​的元素移动到bib_ibi​。 例如： (13213244)(14233241)=(13213244)(14233241)=(12243341)\left(\begin{array}{c}1\\ 3\end{array} \begin{array}{c}2\\ 1\end{array} \begin{array}{c}3\\ 2\end{array} \begin{array}{c}4\\ 4\end{array} \right) \left(\begin{array}{c}1\\ 4\end{array} \begin{array}{c}2\\ 3\end{array} \begin{array}{c}3\\ 2\end{array} \begin{array}{c}4\\ 1\end{array} \right)= \left(\begin{array}{c}1\\ 3\end{array} \begin{array}{c}2\\ 1\end{array} \begin{array}{c}3\\ 2\end{array} \begin{array}{c}4\\ 4\end{array} \right) \left(\begin{array}{c}1\\ 4\end{array} \begin{array}{c}2\\ 3\end{array} \begin{array}{c}3\\ 2\end{array} \begin{array}{c}4\\ 1\end{array} \right) =\left(\begin{array}{c}1\\ 2\end{array} \begin{array}{c}2\\ 4\end{array} \begin{array}{c}3\\ 3\end{array} \begin{array}{c}4\\ 1\end{array} \right) (13​21​32​44​)(14​23​32​41​)=(13​21​32​44​)(14​23​32​41​)=(12​24​33​41​) Burnside引理 例题 将一个正方形分成444格，每个格子可以染成黑色或者白色，有多少种方案？经过旋转得到相同的图像算一种。 内容 BurnsidBurnsidBurnsid引理是群论中的一个结论，在组合数学中可用于计算等价类的个数，常用于PolyaPolyaPolya计数。 BurnsidBurnsidBurnsid引理：用D(aj)D(a_j)D(aj​)表示在置换aja_jaj​下不变的元素的个数。LLL表示本质不同的方案数。 L=1∣G∣∑j=1nD(aj)L=\frac{1}{|G|}\sum_{j=1}^nD(a_j) L=∣G∣1​j=1∑n​D(aj​) 其中置换群G={G=\{G={转90∘90^\circ90∘,转180∘180^\circ180∘,转270∘270^\circ270∘ }\}} 把正方形的格子编号为 1423\begin{array}{c}1\\ 4\end{array}\begin{array}{c}2\\ 3\end{array} 14​23​ 转000度：]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>Polya</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「POJ2409」Let it Bead]]></title>
    <url>%2Fpost%2Fea82696f.html</url>
    <content type="text"><![CDATA[Description 项链由nnn个珠子组成，每个珠子可以染成ccc种不同的颜色，试求出一共可以设计出多少种本质不同的项链。 Solution 每个珠子顺指针旋转xxx布，可以证明循环节的个数有gcd(x,n)gcd(x,n)gcd(x,n)个。 假设当前位置是ppp,那么他的循环是ppp、p+xp+xp+x、⋯\cdots⋯、 p+kxp+kxp+kx 就是p+kx≡p(modn)p+kx\equiv p\pmod{n}p+kx≡p(modn) →\to→ kx≡0(modn)kx\equiv 0\pmod{n}kx≡0(modn) 我们要的是kkk的最小正整数解 n∣kxn|kx n∣kx 同时 x∣kxx|kx x∣kx 所以kx=lcm(x,n)kx=lcm(x,n)kx=lcm(x,n) ⇒\Rightarrow⇒ k=xn÷gcd(x,n)÷x=ngcd(x,n)k=xn\div gcd(x,n)\div x=\frac{n}{gcd(x,n)}k=xn÷gcd(x,n)÷x=gcd(x,n)n​ 那么p+1p+1p+1、p+2p+2p+2直到p+x−1p+x-1p+x−1都是可以独立成为一个循环节。 所以枚举一个循环长度xxx，那么它的循环节长度为gcd(x,n)gcd(x,n)gcd(x,n)。即 ∑x=1ncgcd(x,n)\sum_{x=1}^{n}c^{gcd(x,n)} x=1∑n​cgcd(x,n) 至此，循环的置换可以解决了，那么翻转的。 nnn是奇数 对于一个位置ppp，以ppp和圆心作对称轴，那么其他每一个点除了ppp点，都有一个对应的，这个每个置换的循环节个数为n+12\frac{n+1}{2}2n+1​ 共nnn个置换 nnn是偶数 一种是以ppp和p+n2p+\frac{n}{2}p+2n​作作对称轴，那么每个置换有n2+1\frac{n}{2}+12n​+1个循环，n/2n/2n/2个置换 一种是以某两个珠子的中点过圆心的情况，那么每个置换有n2\frac{n}{2}2n​个循环。共n−1n-1n−1个，共n/2n/2n/2个置换 根据Pólya定理，把两部分加起来除以置换的个数就可以了 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;cmath&gt;#include&lt;bitset&gt;#define mk make_pair#define fi first#define nd second#define pii pair&lt;int,int&gt;#define pb push_back#define sqr(x) ((x)*(x))using namespace std;typedef long long ll;inline ll read() &#123;ll x = 0; char ch = getchar(), w = 1;while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') w = -1;ch = getchar();&#125;while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0';ch = getchar();&#125;return x * w;&#125;void write(ll x) &#123;if(x &lt; 0) putchar('-'), x = -x;if(x &gt; 9) write(x / 10);putchar(x % 10 + '0');&#125;inline void writeln(ll x) &#123;write(x);puts("");&#125;int c, n;int gcd(int x, int y) &#123; if(!y) return x; return gcd(y, x % y);&#125;int main() &#123; while(1) &#123; c = read(), n = read(); if(!c &amp;&amp; !n) break; ll ans = 0; for(int i = 1; i &lt;= n; ++i) ans += pow(c, gcd(i, n)); if(n &amp; 1) ans += pow(c, n / 2 + 1) * (ll)n; else &#123; ans += (n / 2) * pow(c, n / 2 + 1); ans += (n / 2) * pow(c, n / 2); &#125; writeln(ans / (2 * n)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>Ploya</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ1096」[ZJOI2007]仓库建设]]></title>
    <url>%2Fpost%2F365bcb26.html</url>
    <content type="text"><![CDATA[Description 有nnn个工厂，每个工厂只能向编号更大的运输产品。每个工厂运输一件产品一单位距离的费用是111。每个工厂可以花费CiC_iCi​单位修建一个无限容量的仓库，且每个工厂有pip_ipi​个产品。问将所有产品放入仓库的最小费用(建造费用+运输费用） Input 第一行包含一个整数N，表示工厂的个数。接下来N行每行包含三个整数XiX_iXi​, PiP_iPi​, CiC_iCi​, 意义如题中所述。 Output 仅包含一个整数，为可以找到最优方案的费用。 Solution 斜率优化 可以写出暴力方程: f[i]=min⁡(f[i],f[j−1]+(t[i]−t[j−1])∗a[i].x−(sum[i]−sum[j−1])+a[i].c);f[i] = \min(f[i], f[j - 1] + (t[i] - t[j - 1]) * a[i].x - (sum[i] - sum[j - 1]) + a[i].c); f[i]=min(f[i],f[j−1]+(t[i]−t[j−1])∗a[i].x−(sum[i]−sum[j−1])+a[i].c); 大力 f[i]f[i]f[i] 在iii设立的最优方案。 x[i]&lt;=f[k−1]+s[k−1]−(f[j−1]+s[j−1]t[k−1]−t[j−1]x[i] &lt;= \frac{f[k - 1] + s[k - 1] - (f[j - 1] + s[j - 1] }{t[k - 1] - t[j - 1]}x[i]&lt;=t[k−1]−t[j−1]f[k−1]+s[k−1]−(f[j−1]+s[j−1]​ 维护凸包。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;bitset&gt;#define mk make_pair#define fi first#define nd second#define pii pair&lt;int,int&gt;#define pb push_back#define sqr(x) ((x)*(x))using namespace std;typedef long long ll;inline ll read() &#123;ll x = 0; char ch = getchar(), w = 1;while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') w = -1;ch = getchar();&#125;while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0';ch = getchar();&#125;return x * w;&#125;void write(ll x) &#123;if(x &lt; 0) putchar('-'), x = -x;if(x &gt; 9) write(x / 10);putchar(x % 10 + '0');&#125;inline void writeln(ll x) &#123;write(x);puts("");&#125;const int N = 2100000;struct node &#123; ll x, p, c;&#125;a[N];ll f[N], s[N], t[N];bool cmp(node x, node y) &#123; return x.x &lt; y.x;&#125;int q[N], head, tail;int n;double slop(int x, int y) &#123; return (double)(f[y - 1] + s[y - 1] - (f[x - 1] + s[x - 1])) / (t[y - 1] - t[x - 1]);&#125;int main() &#123; n = read(); for(int i = 1; i &lt;= n; ++i) a[i].x = read(), a[i].p = read(), a[i].c = read(); sort(a +1, a + 1 + n, cmp); for(int i = 1;i &lt;= n; ++i) s[i] = s[i - 1] + a[i].x * a[i].p, t[i] = t[i - 1] + a[i].p; head = 1; for(int i = 1; i &lt;= n; ++i) &#123; while(head &lt; tail &amp;&amp; slop(q[tail - 1], q[tail]) &gt;= slop(q[tail - 1], i))--tail; q[++tail] = i; while(head &lt; tail &amp;&amp; slop(q[head], q[head + 1]) &lt;= a[i].x) ++head; f[i] = f[q[head] - 1] - t[q[head] - 1] * a[i].x + s[q[head] - 1] + t[i] * a[i].x + a[i].c - s[i]; &#125; writeln(f[n]); return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ3240」[Noi2013]矩阵游戏]]></title>
    <url>%2Fpost%2F39ae0330.html</url>
    <content type="text"><![CDATA[Description F[1][1]=1F[1][1]=1 F[1][1]=1 F[i,j]=a∗F[i][j−1]+b(j!=1)F[i,j]=a*F[i][j-1]+b (j!=1) F[i,j]=a∗F[i][j−1]+b(j!=1) F[i,1]=c∗F[i−1][m]+d(i≠1)F[i,1]=c*F[i-1][m]+d (i\neq 1) F[i,1]=c∗F[i−1][m]+d(i≠1) 递推式中aaa,bbb,ccc,ddd都是给定的常数。 现在婷婷想知道F[n][m]F[n][m]F[n][m]的值是多少. Input 一行有六个整数nnn,mmm,aaa,bbb,ccc,ddd。意义如题所述 Output 包含一个整数，表示F[n][m]F[n][m]F[n][m]除以1,000,000,0071,000,000,0071,000,000,007的余数 Solution 矩阵乘法也是满足费马小定理的。 设矩阵从左到右转移是A1A_1A1​，从上到下转移是A2A_2A2​ 答案是就是A1(A1A2)n−1A_1(A_1A_2)^{n-1}A1​(A1​A2​)n−1 A1=[a0b1]A_1=\begin{bmatrix}a &amp; 0 \\b &amp; 1 \end{bmatrix}A1​=[ab​01​] A2=[c0d1]A_2=\begin{bmatrix}c &amp; 0 \\d &amp; 1 \end{bmatrix}A2​=[cd​01​] 初始矩阵T=[11]T=\begin{bmatrix}1 &amp; 1\end{bmatrix}T=[1​1​] a=1a=1a=1或者c=1c=1c=1要特判，因为转移变成线性了，那么费马小定理不适用，模数要等于ppp。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;bitset&gt;#define mk make_pair#define fi first#define nd second#define pii pair&lt;int,int&gt;#define pb push_back#define sqr(x) ((x)*(x))using namespace std;typedef long long ll;inline ll read() &#123;ll x = 0; char ch = getchar(), w = 1;while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') w = -1;ch = getchar();&#125;while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0';ch = getchar();&#125;return x * w;&#125;void write(ll x) &#123;if(x &lt; 0) putchar('-'), x = -x;if(x &gt; 9) write(x / 10);putchar(x % 10 + '0');&#125;inline void writeln(ll x) &#123;write(x);puts("");&#125;const ll p = 1000000007;const int N = 2000100;ll n, m ,a,b,c,d;inline ll ksm(ll x, ll y) &#123; ll res = 1; for(; y; y &gt;&gt;= 1, x = x * x % p) if(y &amp; 1) res = res * x %p; return res;&#125;char s1[N], s2[N];ll readl(char *s, ll Mod) &#123; int len = strlen(s + 1); ll res = 0; for(int i = 1; i &lt;= len; ++i) res = (res * 10 + s[i] - '0') % Mod; return res;&#125;struct Matrix &#123; ll a[3][3]; Matrix () &#123;memset(a,0,sizeof a);&#125; Matrix operator * (const Matrix b) &#123; Matrix c; memset(c.a, 0, sizeof c.a); for(int i = 0; i &lt; 2; ++i) for(int j = 0; j &lt; 2; ++j) for(int k = 0; k &lt; 2; ++k) c.a[i][j] += a[i][k] * b.a[k][j] % p; for(int i = 0; i &lt; 2; ++i) for(int j = 0; j &lt; 2; ++j) c.a[i][j] %= p; return c; &#125;&#125;t,a1,a2,res,tmp;Matrix ksm(Matrix x, ll y) &#123; y %= (p - 1); Matrix res; for(int i =0; i &lt; 2; ++i) res.a[i][i] = 1; for(; y; y &gt;&gt;= 1, x = x * x) if(y &amp; 1) res = res * x; return res;&#125;int main() &#123; scanf("%s%s",s1 + 1, s2 +1); a = read(), b = read(), c = read(), d = read(); if(c == 1) n = readl(s1, p); else n = readl(s1, p - 1); if(a == 1) m = readl(s2, p); else m = readl(s2, p - 1); t.a[0][0] = 1, t.a[0][1] = 1; a1.a[0][0] = a, a1.a[1][0] = b, a1.a[1][1] = 1; a2.a[0][0] = c, a2.a[1][0] = d, a2.a[1][1] = 1; tmp = a1; a1 = ksm(a1, m - 1 + p - 1); a1 = a1 * a2; a1 = ksm(a1, n - 1 + p - 1); a1 = a1 * ksm(tmp, m - 1 + p - 1); t = t * a1; writeln(t.a[0][0]); return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ2820」YY的GCD]]></title>
    <url>%2Fpost%2F79b569af.html</url>
    <content type="text"><![CDATA[Description 给定NNN, MMM,求1≤x≤N1\leq x\leq N1≤x≤N, 1≤y≤M1\leq y\leq M1≤y≤M且gcd(x,y)gcd(x, y)gcd(x,y)为质数的(x,y)(x, y)(x,y)有多少对。 Input 第一行一个整数TTT表述数据组数接下来TTT行，每行两个正整数，表示NNN,MMM。 Output TTT行，每行一个整数表示第iii组数据的结果 HINT T=10000T=10000T=10000 N,M≤10000000N,M\leq10000000N,M≤10000000 Solution 这题和「BZOJ2301」类似。 定义： F(p)F(p)F(p)表示p∣gcd(x,y)p|gcd(x,y)p∣gcd(x,y)的点对个数，其中p∈primep\in primep∈prime。 f(i)f(i)f(i)表示gcd(x,y)=igcd(x,y)=igcd(x,y)=i的点对个数。 F(p)=∑p∣df(d)F(p)=\sum_{p|d}f(d) F(p)=p∣d∑​f(d) 反演FFF函数可以得到 f(p)=∑p∣dμ(dp)F(d)f(p)=\sum_{p|d}\mu(\frac{d}{p})F(d) f(p)=p∣d∑​μ(pd​)F(d) 显然d=kp,k∈Nd=kp,k\in Nd=kp,k∈N Ans=∑p∑p∣dμ(dp)F(d)Ans=\sum_{p}\sum_{p|d}\mu(\frac{d}{p})F(d) Ans=p∑​p∣d∑​μ(pd​)F(d) 仔细考虑一下，对于每一个ddd，乘以∑p∣dμ(dp)\sum_{p|d}\mu(\frac{d}{p})∑p∣d​μ(pd​) 所以 Ans=∑dF(d)∑p∣dμ(dp)Ans=\sum_d F(d)\sum_{p|d}\mu(\frac{d}{p}) Ans=d∑​F(d)p∣d∑​μ(pd​) F(d)=⌊Nd⌋⌊Md⌋F(d)=\lfloor\frac{N}{d}\rfloor\lfloor\frac{M}{d}\rfloorF(d)=⌊dN​⌋⌊dM​⌋可以分块处理 ∑p∣dμ(dp)F(d)\sum_{p|d}\mu(\frac{d}{p})F(d)∑p∣d​μ(pd​)F(d)可以枚举质数ppp,然后去更新它的倍数。tottottot的个质数复杂度是∑pNNp\sum_{p}^{N}\frac{N}{p}∑pN​pN​ 大概是n÷ln(n)×(ln(n))2n\div ln(n)\times (ln(n))^2n÷ln(n)×(ln(n))2 我也不太会算。 加上分块，总的复杂度是O(Nlog⁡n+NT)O(N\log n+\sqrt{N}T)O(Nlogn+N​T) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;bitset&gt;#define mk make_pair#define fi first#define nd second#define pii pair&lt;int,int&gt;#define pb push_back#define sqr(x) ((x)*(x))using namespace std;typedef long long ll;inline ll read() &#123;ll x = 0; char ch = getchar(), w = 1;while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') w = -1;ch = getchar();&#125;while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0';ch = getchar();&#125;return x * w;&#125;void write(ll x) &#123;if(x &lt; 0) putchar('-'), x = -x;if(x &gt; 9) write(x / 10);putchar(x % 10 + '0');&#125;inline void writeln(ll x) &#123;write(x);puts("");&#125;const int N = 1e7 + 6;bool v[N];int mu[N],p[N], tot;ll s[N];void pre()&#123; mu[1] = 1; for(int i = 2; i &lt;= 1e7; ++i) &#123; if(!v[i]) mu[i] = -1, p[++tot] = i; for(int j = 1; j &lt;= tot &amp;&amp; i &lt;= 1e7/p[j]; ++j)&#123; v[i * p[j]] = 1; if(i % p[j] == 0) &#123; mu[i * p[j]] = 0; break; &#125; mu[i * p[j]] = -mu[i]; &#125; &#125; for(int i = 1; i &lt;= tot; ++i) for(int j = 1; j &lt;= 1e7 / p[i]; ++j) s[j * p[i]] += mu[j]; for(int i = 1; i &lt;= 1e7; ++i) s[i] += s[i - 1];&#125;int n, m;ll solve() &#123; ll res = 0;/* for(int i = 1; i &lt;= tot &amp;&amp; p[i] &lt;= min(n, m); ++i) &#123; for(int j = 1; j * p[i] &lt;= min(n, m); ++j) res += (ll)mu[j] * (n / (p[i] * j)) * (m / (p[i] * j)); &#125;*/ for(int i = 1, r; i &lt;= min(n, m); i = r +1) &#123; r = min(n / (n / i), m / (m / i)); res += (ll)(n / i) * (m / i) * (s[r] - s[i - 1]); &#125; return res; &#125;int main() &#123; int T = read(); pre(); while(T--) &#123; n = read(), m = read(); writeln(solve()); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ2301」[HAOI2011]Problem b]]></title>
    <url>%2Fpost%2F2c9e796c.html</url>
    <content type="text"><![CDATA[Description 对于给出的nnn个询问，每次求有多少个数对(x,y)(x,y)(x,y)，满足a≤x≤ba\leq x\leq ba≤x≤b，c≤y≤dc\leq y\leq dc≤y≤d，且gcd(x,y)=kgcd(x,y)=kgcd(x,y)=k，gcd(x,y)gcd(x,y)gcd(x,y)函数为xxx和yyy的最大公约数。 Input 第一行一个整数n，接下来n行每行五个整数，分别表示a、bbb、ccc、ddd、kkk Output 共nnn行，每行一个整数表示满足要求的数对(x,y)(x,y)(x,y)的个数 Solution f(i)f(i)f(i)表示x∈[1,n]x\in[1,n]x∈[1,n]，y∈[1,m]y\in[1,m]y∈[1,m]且gcd(x,y)=igcd(x,y)=igcd(x,y)=i的数对(x,y)(x,y)(x,y)数量 F(i)F(i)F(i)表示x∈[1,n]x\in[1,n]x∈[1,n]，y∈[1,m]y\in[1,m]y∈[1,m]且i∣gcd(x,y)i|gcd(x,y)i∣gcd(x,y)的数对(x,y(x,y(x,y数量 F(i)=∑i∣df(d)=⌊ni⌋⌊mi⌋F(i)=\sum_{i|d}f(d)=\lfloor\frac{n}{i}\rfloor\lfloor\frac{m}{i}\rfloor F(i)=i∣d∑​f(d)=⌊in​⌋⌊im​⌋ 反演FFF函数得到： f(i)=∑i∣dμ(di)F(d)=∑i∣dμ(di)⋅⌊nd⌋⌊md⌋f(i)=\sum_{i|d}\mu(\frac{d}{i})F(d)=\sum_{i|d}\mu(\frac{d}{i})\cdot \lfloor\frac{n}{d}\rfloor\lfloor\frac{m}{d}\rfloor f(i)=i∣d∑​μ(id​)F(d)=i∣d∑​μ(id​)⋅⌊dn​⌋⌊dm​⌋ O(50000n)O(50000n)O(50000n)还过不了题目，分块求后面部分就能达到优秀的O(nsqrt(50000))O(nsqrt(50000))O(nsqrt(50000)) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;bitset&gt;#define mk make_pair#define fi first#define nd second#define pii pair&lt;int,int&gt;#define pb push_back#define sqr(x) ((x)*(x))using namespace std;typedef long long ll;inline ll read() &#123;ll x = 0; char ch = getchar(), w = 1;while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') w = -1;ch = getchar();&#125;while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0';ch = getchar();&#125;return x * w;&#125;void write(ll x) &#123;if(x &lt; 0) putchar('-'), x = -x;if(x &gt; 9) write(x / 10);putchar(x % 10 + '0');&#125;inline void writeln(ll x) &#123;write(x);puts("");&#125;int k;const int N = 61000;int miu[N];bool v[N];int p[N], tot;void pre() &#123; miu[1] = 1; for(int i = 2; i &lt;= 50000; ++i) &#123; if(!v[i]) p[++tot] = i, miu[i] = -1; for(int j = 1; j &lt;= tot; ++j) &#123; if(p[j] &gt; 50000/ i) break; v[i * p[j]] = 1; if(i % p[j] == 0) &#123; miu[i * p[j]] = 0; break; &#125; miu[i * p[j]] = -miu[i]; &#125; &#125; for(int i = 1; i &lt;= 50000; ++i) miu[i] += miu[i - 1];&#125;ll solve(int n, int m) &#123; ll res = 0; /*for(int i = k; i &lt;= min(n, m); i += k) res += miu[i / k] * (n / i) * (m / i);*/ //printf("n=%d,m=%d\n",n,m); for(int i = 1, r; i * k &lt;= min(n, m); i = r + 1) &#123; r = min(n / (n / i), m / (m / i)); res += (ll)(miu[r] - miu[i - 1]) * (n / k / i) * (m / k / i); //printf("i=%d,r=%d,%d\n", i, r,(miu[r] - miu[i - 1]) * (n / i) * (m / i)); &#125; return res;&#125;int main() &#123; pre(); int T = read(); while(T--) &#123; int a = read(), b = read(), c = read(), d = read(); k = read(); writeln(solve(b,d) - solve(b, c - 1) - solve(a - 1, d) + solve(a - 1, c - 1)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>莫比乌斯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欧拉公式]]></title>
    <url>%2Fpost%2F9401e9ac.html</url>
    <content type="text"><![CDATA[欧拉公式 前言 今天博主在b站上看完了一个视频。此视频介绍了欧拉从定义π\piπ、以欧拉命名、伯努利发明的数eee、sinsinsin和coscoscos以及eie^iei、eee的泰勒展开式以及虚数iii。 最近几天要学FFTFFTFFT，这是一篇学习笔记希望能以新的角度审视数学，有错误的话，感谢评论里指出。 前置知识 幂法则 如果f(x)=xnf(x)=x^nf(x)=xn，那么f′(x)=nxn−1f&#x27;(x)=nx^{n-1}f′(x)=nxn−1 证明 新的函数值是f(x+dx)=(x+dx)n=(x+dx)(x+dx)(x+dx)⋯(x+dx)f(x+\mathrm{d}x)=(x+\mathrm{d}x)^n=(x+\mathrm{d}x)(x+\mathrm{d}x)(x+\mathrm{d}x)\cdots(x+\mathrm{d}x)f(x+dx)=(x+dx)n=(x+dx)(x+dx)(x+dx)⋯(x+dx) 可以由二项式定理得到 (x+dx)n=∑i=0n(in)xn−i(dx)i=(0n)xn+(1n)xn−1dx+(2n)xn−2(dx)2⋯(x+\mathrm{d}x)^n=\sum^{n}_{i=0}\left(\begin{array}{c}i\\ n\end{array}\right)x^{n-i}(\mathrm{d}x)^i=\left(\begin{array}{c}0\\ n\end{array}\right)x^n+\left(\begin{array}{c}1\\ n\end{array}\right)x^{n-1}\mathrm{d}x+\left(\begin{array}{c}2\\ n\end{array}\right)x^{n-2}(\mathrm{d}x)^2\cdots (x+dx)n=i=0∑n​(in​)xn−i(dx)i=(0n​)xn+(1n​)xn−1dx+(2n​)xn−2(dx)2⋯ df=f(x+dx)−f(x)=xn−1dx+xn−2(dx)2⋯df=f(x+\mathrm{d}x)-f(x)=x^{n-1}\mathrm{d}x+x^{n-2}(\mathrm{d}x)^2\cdots df=f(x+dx)−f(x)=xn−1dx+xn−2(dx)2⋯ dfdx=xn−1+n(n−1)2xn−2dx+n(n−1)(n−2)6xn−2dx⋯\frac{df}{dx}=x^{n-1}+\frac{n(n-1)}{2}x^{n-2}dx+\frac{n(n-1)(n-2)}{6}x^{n-2}dx\cdots dxdf​=xn−1+2n(n−1)​xn−2dx+6n(n−1)(n−2)​xn−2dx⋯ 因为dxdxdx趋向000,所以可以忽略含有dxdxdx的项,dfdx=xn−1\frac{df}{dx}=x^{n-1}dxdf​=xn−1 加法则 两个函数f(x)f(x)f(x)、g(x)g(x)g(x)，那么(f(x)+g(x))′=f′(x)+g′(x)(f(x)+g(x))&#x27;=f&#x27;(x)+g&#x27;(x)(f(x)+g(x))′=f′(x)+g′(x) 积法则 两个函数f(x)f(x)f(x)、g(x)g(x)g(x)，那么(f(x)g(x))′=f(x)g′(x)+f′(x)g(x)(f(x)g(x))&#x27;=f(x)g&#x27;(x)+f&#x27;(x)g(x)(f(x)g(x))′=f(x)g′(x)+f′(x)g(x) 证明 由于相乘想到面积来可视化过程，设一个矩形长宽分别为f(x)f(x)f(x)、g(x)g(x)g(x)，设h(x)=(f(x)g(x))′h(x)=(f(x)g(x))&#x27;h(x)=(f(x)g(x))′ 如图所示： 显然增加的面积就是三块有颜色面积的小矩形，绿红黄他们的面积之和为： f(x)d(g(x))+g(x)d(f(x))+d(f(x))d(g(x))=h′(x)dx⇒f(x)\mathrm{d}(g(x))+g(x)\mathrm{d}(f(x))+\mathrm{d}(f(x))\mathrm{d}(g(x))=h&#x27;(x)\mathrm{d}x\Rightarrow f(x)d(g(x))+g(x)d(f(x))+d(f(x))d(g(x))=h′(x)dx⇒ f(x)g′(x)dx+g(x)f′(x)dx+g′(x)dxf′(x)dx=h′(x)dxf(x)g&#x27;(x)\mathrm{d}x+g(x)f&#x27;(x)\mathrm{d}x+g&#x27;(x)\mathrm{d}xf&#x27;(x)\mathrm{d}x=h&#x27;(x)\mathrm{d}x f(x)g′(x)dx+g(x)f′(x)dx+g′(x)dxf′(x)dx=h′(x)dx 那么h′(x)dx=f(x)g′(x)+g(x)f′(x)+g′(x)f′(x)dx\frac{h&#x27;(x)}{dx}=f(x)g&#x27;(x)+g(x)f&#x27;(x)+g&#x27;(x)f&#x27;(x)\mathrm{d}xdxh′(x)​=f(x)g′(x)+g(x)f′(x)+g′(x)f′(x)dx 发现尾项与dx\mathrm{d}xdx有关，当dx\mathrm{d}xdx趋向000的时候可以忽略。 链式法则 两个函数f(x)f(x)f(x)、g(x)g(x)g(x)，那么f′(g(x))=f′(g(x))g′(x)f&#x27;(g(x))=f&#x27;(g(x))g&#x27;(x)f′(g(x))=f′(g(x))g′(x)，也就是dfdx=dfdgdgdx\frac{\mathrm{d}f}{\mathrm{d}x}=\frac{\mathrm{d}f}{\mathrm{d}g}\frac{\mathrm{d}g}{\mathrm{d}x}dxdf​=dgdf​dxdg​ 证明 当xxx变化量为dxdxdx的时候,ggg函数变化量是d(g(x))\mathrm{d}(g(x))d(g(x))。 fff函数的变化量为： d(f(g(x)))=f′(g(x))d(g(x))=f′(g(x))g′(x)dx⇒d(f(g(x))dx=f′(g(x))g′(x)\mathrm{d}(f(g(x)))=f&#x27;(g(x))\mathrm{d}(g(x))=f&#x27;(g(x))g&#x27;(x)\mathrm{d}x\Rightarrow \frac{\mathrm{d}(f(g(x))}{\mathrm{d}x}=f&#x27;(g(x))g&#x27;(x) d(f(g(x)))=f′(g(x))d(g(x))=f′(g(x))g′(x)dx⇒dxd(f(g(x))​=f′(g(x))g′(x) 最后一步是由导数的定义得来的。 通过幂法则、链式法则推到商法则 三角函数的导数 sin⁡′(x)=cos(x)\sin&#x27;(x)=cos(x)sin′(x)=cos(x) cos⁡′(x)=−sin(x)\cos&#x27;(x)=-sin(x)cos′(x)=−sin(x) 证明 高阶导数 f(n)(x)f^{(n)}(x)f(n)(x)指的是f(x)f(x)f(x)的nnn阶导数。我自己的理解：描述f(x)f(x)f(x)的变化函数是f′(x)f&#x27;(x)f′(x)，描述f′(x)f&#x27;(x)f′(x)的变化函数f′′(x)f&#x27;&#x27;(x)f′′(x)，也就是f(n)f^{(n)}f(n)的变化受到f(n+1)f^{(n+1)}f(n+1)的控制，如果控制f1f^1f1、f2f^2f2···他们的函数都相等，那么&quot;理论上&quot;这两个函数是相等的。下面泰勒级数就用到这个思想。 拓展（无关本文) 指数函数求导 尝试求导 M(t)=2tM(t)=2^tM(t)=2t dMdt=2t+dt−2tdt=2t(2dt−1dt)⎵dt→0\frac{\mathrm{d}M}{\mathrm{d}t}=\frac{2^{t+\mathrm{d}t}-2^t}{\mathrm{d}t}=2^t\underbrace{(\frac{2^{\mathrm{d}t}-1}{\mathrm{d}t})}_{dt\to0} dtdM​=dt2t+dt−2t​=2tdt→0(dt2dt−1​)​​ 2dt−1dt\frac{2^{\mathrm{d}t}-1}{\mathrm{d}t}dt2dt−1​趋向于一个常数0.69314718056⋯0.69314718056\cdots0.69314718056⋯ 同样函数M(t)=3tM(t)=3^tM(t)=3t同样的方法，后半部分将趋向于1.09861228867⋯1.09861228867\cdots1.09861228867⋯ M(t)=8t→2.07944154168⋯M(t)=8^t\to 2.07944154168\cdotsM(t)=8t→2.07944154168⋯ 1.09861228867⋯×3=2.07944154168⋯1.09861228867\cdots{\times3}=2.07944154168\cdots1.09861228867⋯×3=2.07944154168⋯ 从指数上8=238=2^38=23，说明这个常数是对于对某个数求对数函数得到的。 有没有哪个底数能是的这个系数为111呢？ 即(at)′=at(a^t)&#x27;=a^t(at)′=at？ e的出现 这个底数就是e=2.71828⋯e=2.71828\cdotse=2.71828⋯ a^x的导数 由上面得到(ax)′=axln⁡(a)(a^x)&#x27;=a^x\ln(a)(ax)′=axln(a) d(ect)dt=cect\frac{d(e^{ct})}{\mathrm{d}t}=ce^{ct}dtd(ect)​=cect，ccc是常数，由复合函数求导。 所有指数函数aaa写作eln⁡(2)e^{\ln(2)}eln(2) 代入上式得到：ax=eln⁡(a)ta^x=e^{\ln(a)t}ax=eln(a)t 隐函数求导 圆的方程式x2+y2=rx^2+y^2=rx2+y2=r，这很显然，如果我们要对它求导怎么办？此时输入一个xxx不一定输出一个yyy。很显然这个函数是可以求导的，也就是求(x,y)(x,y)(x,y)这个坐标的斜率。 泰勒级数 由来 一个函数可以写成f(x)=∑i=0naixi=a0+a1x1+a2x2+⋯f(x)=\sum^n_{i=0}{a_ix^i}=a_0+a_1x_1+a_2x_2+\cdotsf(x)=∑i=0n​ai​xi=a0​+a1​x1​+a2​x2​+⋯ 在高阶导数的时候说过，如果两个函数每一阶导数都相等，那么&quot;理论上&quot;两个函数是相等的。 因为我们有cos′(x)=−sin(x)cos&#x27;(x)=-sin(x)cos′(x)=−sin(x)、cos′′(x)=−cos(x)cos&#x27;&#x27;(x)=-cos(x)cos′′(x)=−cos(x)、cos′′′(x)=sin(x)cos&#x27;&#x27;&#x27;(x)=sin(x)cos′′′(x)=sin(x)、cos′′′′(x)=cos(x)cos&#x27;&#x27;&#x27;&#x27;(x)=cos(x)cos′′′′(x)=cos(x) 此后就是−sin(x)-sin(x)−sin(x)、−cos(x)-cos(x)−cos(x)、sin(x)sin(x)sin(x)、cos(x)cos(x)cos(x)循环，求导次数xxx，其xmod 4=1x \mod\ 4=1xmod 4=1,222,333,000的时候分别对应这四个。 cos(0)=1⇒f(x)=a0+∑i=1nai⋅0=a0=1cos(0)=1\Rightarrow f(x)=a_0+\sum_{i=1}^n{a_i\cdot0}=a_0=1cos(0)=1⇒f(x)=a0​+∑i=1n​ai​⋅0=a0​=1 cos′(0)=0⇒f′(x)=1⋅a1+∑i=2n(i−1)ai⋅0=1!⋅a1=0cos&#x27;(0)=0\Rightarrow f&#x27;(x)=1\cdot a_1+\sum_{i=2}^n{(i-1)a_i\cdot0}=1!\cdot a_1=0cos′(0)=0⇒f′(x)=1⋅a1​+∑i=2n​(i−1)ai​⋅0=1!⋅a1​=0 cos⁡′′(0)=−1⇒f′′(x)=1⋅2⋅a2+∑i=3n(i−1)⋅(i−2)ai=2!⋅a2=−1\cos&#x27;&#x27;(0)=-1\Rightarrow f&#x27;&#x27;(x)=1\cdot2\cdot a_2+\sum_{i=3}^n{(i-1)\cdot(i-2)a_i}=2!\cdot a_2=-1cos′′(0)=−1⇒f′′(x)=1⋅2⋅a2​+∑i=3n​(i−1)⋅(i−2)ai​=2!⋅a2​=−1 cos′′′(0)=0⇒f′′′(x)=1⋅2⋅3a3+∑i=4n(i−1)⋅(i−2)⋅(i−3)ai=3!⋅a3=0cos&#x27;&#x27;&#x27;(0)=0\Rightarrow f&#x27;&#x27;&#x27;(x)=1\cdot2\cdot3 a_3+\sum_{i=4}^n{(i-1)\cdot(i-2)\cdot(i-3)a_i}=3!\cdot a_3=0cos′′′(0)=0⇒f′′′(x)=1⋅2⋅3a3​+∑i=4n​(i−1)⋅(i−2)⋅(i−3)ai​=3!⋅a3​=0 cos′′′′(0)=1⇒f′′′′(x)=1⋅2⋅3⋅4a4+∑i=5n(i−1)⋅(i−2)⋅(i−3)⋅(i−4)ai=4!⋅a4=1cos&#x27;&#x27;&#x27;&#x27;(0)=1\Rightarrow f&#x27;&#x27;&#x27;&#x27;(x)=1\cdot2\cdot3\cdot4 a_4+\sum_{i=5}^n{(i-1)\cdot(i-2)\cdot(i-3)\cdot(i-4)a_i}=4!\cdot a_4=1cos′′′′(0)=1⇒f′′′′(x)=1⋅2⋅3⋅4a4​+∑i=5n​(i−1)⋅(i−2)⋅(i−3)⋅(i−4)ai​=4!⋅a4​=1 可以发现规律了，假设取了iii次导数，且有i=2ni=2ni=2n。 nnn是奇数有：i!⋅ai=−1⇒ai=−1i!i!\cdot a_i=-1\Rightarrow a_i=-\frac{1}{i!}i!⋅ai​=−1⇒ai​=−i!1​ nnn是偶数有：i!⋅ai=1⇒ai=1i!i!\cdot a_i=1\Rightarrow a_i=\frac{1}{i!}i!⋅ai​=1⇒ai​=i!1​ 也就是cos(x)=1−x22!+x44!−x66!+x48!−⋯cos(x)=1-\frac{x^2}{2!}+\frac{x^4}{4!}-\frac{x^6}{6!}+\frac{x^4}{8!}-\cdotscos(x)=1−2!x2​+4!x4​−6!x6​+8!x4​−⋯ 同样的思路可以证明sin⁡(x)=∑i=2n+1,n∈N∞(−1)nxii!=x−x33!+x55!−x77!+⋯\sin(x)=\sum^{\infty}_{i=2n+1,n\in N}{(-1)^n\frac{x^i}{i!}}=x-\frac{x^3}{3!}+\frac{x^5}{5!}-\frac{x^7}{7!}+\cdotssin(x)=∑i=2n+1,n∈N∞​(−1)ni!xi​=x−3!x3​+5!x5​−7!x7​+⋯ 证明ex=⋯e^x=\cdotsex=⋯比这更容易，根据定义(ex)′=ex(e^x)&#x27;=e^x(ex)′=ex，重复上述过程即可。 麦克劳林展开式 ex=∑i=0∞xii!=1+x11!+x22!+x33!+x44!+⋯e^x=\sum^\infty_{i=0}{\frac{x^i}{i!}}=1+\frac{x^1}{1!}+\frac{x^2}{2!}+\frac{x^3}{3!}+\frac{x^4}{4!}+\cdotsex=∑i=0∞​i!xi​=1+1!x1​+2!x2​+3!x3​+4!x4​+⋯ sin⁡(x)=∑i=2n+1,n∈N∞(−1)nxii!=x−x33!+x55!−x77!+⋯\sin(x)=\sum^{\infty}_{i=2n+1,n\in N}{(-1)^n\frac{x^i}{i!}}=x-\frac{x^3}{3!}+\frac{x^5}{5!}-\frac{x^7}{7!}+\cdotssin(x)=∑i=2n+1,n∈N∞​(−1)ni!xi​=x−3!x3​+5!x5​−7!x7​+⋯ cos⁡(x)=∑i=2n,n∈N∞(−1)nxii!=1−x22!+x44!−x66!+⋯\cos(x)=\sum^{\infty}_{i=2n,n\in N}(-1)^n\frac{x^i}{i!}=1-\frac{x^2}{2!}+\frac{x^4}{4!}-\frac{x^6}{6!}+\cdotscos(x)=∑i=2n,n∈N∞​(−1)ni!xi​=1−2!x2​+4!x4​−6!x6​+⋯ 本文正题 eix=1+(ix)11!+(ix)22!+(ix)33!+(ix)44!+(ix)55!=1+ix1!−x22!−ix33!+x44!+ix55!−⋯e^{ix}=1+\frac{(ix)^1}{1!}+\frac{(ix)^2}{2!}+\frac{(ix)^3}{3!}+\frac{(ix)^4}{4!}+\frac{(ix)^5}{5!}=1+\frac{ix}{1!}-\frac{x^2}{2!}-\frac{ix^3}{3!}+\frac{x^4}{4!}+\frac{ix^5}{5!}-\cdotseix=1+1!(ix)1​+2!(ix)2​+3!(ix)3​+4!(ix)4​+5!(ix)5​=1+1!ix​−2!x2​−3!ix3​+4!x4​+5!ix5​−⋯ 把带有iii的提出来有： eix=1−x22!+x44!−x66!+⋯+i(x−x33!+x55!−x77!)=cos(x)+i×sin(x)e^{ix}=1-\frac{x^2}{2!}+\frac{x^4}{4!}-\frac{x^6}{6!}+\cdots+i(x-\frac{x^3}{3!}+\frac{x^5}{5!}-\frac{x^7}{7!})=cos(x)+i\times sin(x)eix=1−2!x2​+4!x4​−6!x6​+⋯+i(x−3!x3​+5!x5​−7!x7​)=cos(x)+i×sin(x) 当x=πx=\pix=π的时候 eiπ=cos⁡(π)+i×sin⁡(π)=−1e^{i\pi}=\cos(\pi)+i\times \sin(\pi)=-1eiπ=cos(π)+i×sin(π)=−1 所以eiπ+1=0e^{i\pi}+1=0eiπ+1=0]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>欧拉公式</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
</search>
