<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Pólya定理学习笔记]]></title>
    <url>%2Fpost%2F393dafff.html</url>
    <content type="text"><![CDATA[定义 置换群 置换群的元素是置换，运算是置换的连接。 置换群是置换的一个集合。 置换一般形式是 (a1b1a2b2a3b3a4b4)\left(\begin{array}{c}a_1\\ b_1\end{array} \begin{array}{c}a_2\\ b_2\end{array} \begin{array}{c}a_3\\ b_3\end{array} \begin{array}{c}a_4\\ b_4\end{array} \right)(a1​b1​​a2​b2​​a3​b3​​a4​b4​​) 其中aaa、bbb分别是1→n1\to n1→n的一个排列。 每一列表示位置为aia_iai​的元素移动到bib_ibi​。 例如： (13213244)(14233241)=(13213244)(14233241)=(12243341)\left(\begin{array}{c}1\\ 3\end{array} \begin{array}{c}2\\ 1\end{array} \begin{array}{c}3\\ 2\end{array} \begin{array}{c}4\\ 4\end{array} \right) \left(\begin{array}{c}1\\ 4\end{array} \begin{array}{c}2\\ 3\end{array} \begin{array}{c}3\\ 2\end{array} \begin{array}{c}4\\ 1\end{array} \right)= \left(\begin{array}{c}1\\ 3\end{array} \begin{array}{c}2\\ 1\end{array} \begin{array}{c}3\\ 2\end{array} \begin{array}{c}4\\ 4\end{array} \right) \left(\begin{array}{c}1\\ 4\end{array} \begin{array}{c}2\\ 3\end{array} \begin{array}{c}3\\ 2\end{array} \begin{array}{c}4\\ 1\end{array} \right) =\left(\begin{array}{c}1\\ 2\end{array} \begin{array}{c}2\\ 4\end{array} \begin{array}{c}3\\ 3\end{array} \begin{array}{c}4\\ 1\end{array} \right) (13​21​32​44​)(14​23​32​41​)=(13​21​32​44​)(14​23​32​41​)=(12​24​33​41​) Burnside引理 例题 将一个正方形分成444格，每个格子可以染成黑色或者白色，有多少种方案？经过旋转得到相同的图像算一种。 内容 BurnsidBurnsidBurnsid引理是群论中的一个结论，在组合数学中可用于计算等价类的个数，常用于PolyaPolyaPolya计数。 BurnsidBurnsidBurnsid引理：用D(aj)D(a_j)D(aj​)表示在置换aja_jaj​下不变的元素的个数。LLL表示本质不同的方案数。 L=1∣G∣∑j=1nD(aj)L=\frac{1}{|G|}\sum_{j=1}^nD(a_j) L=∣G∣1​j=1∑n​D(aj​) 其中置换群G={G=\{G={转90∘90^\circ90∘,转180∘180^\circ180∘,转270∘270^\circ270∘ }\}}]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>Polya</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「POJ2409」Let it Bead]]></title>
    <url>%2Fpost%2Fea82696f.html</url>
    <content type="text"><![CDATA[Description 项链由nnn个珠子组成，每个珠子可以染成ccc种不同的颜色，试求出一共可以设计出多少种本质不同的项链。 Solution 每个珠子顺指针旋转xxx布，可以证明循环节的个数有gcd(x,n)gcd(x,n)gcd(x,n)个。 假设当前位置是ppp,那么他的循环是ppp、p+xp+xp+x、⋯\cdots⋯、 p+kxp+kxp+kx 就是p+kx≡p(modn)p+kx\equiv p\pmod{n}p+kx≡p(modn) →\to→ kx≡0(modn)kx\equiv 0\pmod{n}kx≡0(modn) 我们要的是kkk的最小正整数解 n∣kxn|kx n∣kx 同时 x∣kxx|kx x∣kx 所以kx=lcm(x,n)kx=lcm(x,n)kx=lcm(x,n) ⇒\Rightarrow⇒ k=xn÷gcd(x,n)÷x=ngcd(x,n)k=xn\div gcd(x,n)\div x=\frac{n}{gcd(x,n)}k=xn÷gcd(x,n)÷x=gcd(x,n)n​ 那么p+1p+1p+1、p+2p+2p+2直到p+x−1p+x-1p+x−1都是可以独立成为一个循环节。 所以枚举一个循环长度xxx，那么它的循环节长度为gcd(x,n)gcd(x,n)gcd(x,n)。即 ∑x=1ncgcd(x,n)\sum_{x=1}^{n}c^{gcd(x,n)} x=1∑n​cgcd(x,n) 至此，循环的置换可以解决了，那么翻转的。 nnn是奇数 对于一个位置ppp，以ppp和圆心作对称轴，那么其他每一个点除了ppp点，都有一个对应的，这个每个置换的循环节个数为n+12\frac{n+1}{2}2n+1​ 共nnn个置换 nnn是偶数 一种是以ppp和p+n2p+\frac{n}{2}p+2n​作作对称轴，那么每个置换有n2+1\frac{n}{2}+12n​+1个循环，n/2n/2n/2个置换 一种是以某两个珠子的中点过圆心的情况，那么每个置换有n2\frac{n}{2}2n​个循环。共n−1n-1n−1个，共n/2n/2n/2个置换 根据Pólya定理，把两部分加起来除以置换的个数就可以了 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;cmath&gt;#include&lt;bitset&gt;#define mk make_pair#define fi first#define nd second#define pii pair&lt;int,int&gt;#define pb push_back#define sqr(x) ((x)*(x))using namespace std;typedef long long ll;inline ll read() &#123;ll x = 0; char ch = getchar(), w = 1;while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') w = -1;ch = getchar();&#125;while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0';ch = getchar();&#125;return x * w;&#125;void write(ll x) &#123;if(x &lt; 0) putchar('-'), x = -x;if(x &gt; 9) write(x / 10);putchar(x % 10 + '0');&#125;inline void writeln(ll x) &#123;write(x);puts("");&#125;int c, n;int gcd(int x, int y) &#123; if(!y) return x; return gcd(y, x % y);&#125;int main() &#123; while(1) &#123; c = read(), n = read(); if(!c &amp;&amp; !n) break; ll ans = 0; for(int i = 1; i &lt;= n; ++i) ans += pow(c, gcd(i, n)); if(n &amp; 1) ans += pow(c, n / 2 + 1) * (ll)n; else &#123; ans += (n / 2) * pow(c, n / 2 + 1); ans += (n / 2) * pow(c, n / 2); &#125; writeln(ans / (2 * n)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>Ploya</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ1096」[ZJOI2007]仓库建设]]></title>
    <url>%2Fpost%2F365bcb26.html</url>
    <content type="text"><![CDATA[Description 有nnn个工厂，每个工厂只能向编号更大的运输产品。每个工厂运输一件产品一单位距离的费用是111。每个工厂可以花费CiC_iCi​单位修建一个无限容量的仓库，且每个工厂有pip_ipi​个产品。问将所有产品放入仓库的最小费用(建造费用+运输费用） Input 第一行包含一个整数N，表示工厂的个数。接下来N行每行包含三个整数XiX_iXi​, PiP_iPi​, CiC_iCi​, 意义如题中所述。 Output 仅包含一个整数，为可以找到最优方案的费用。 Solution 斜率优化 可以写出暴力方程: f[i]=min⁡(f[i],f[j−1]+(t[i]−t[j−1])∗a[i].x−(sum[i]−sum[j−1])+a[i].c);f[i] = \min(f[i], f[j - 1] + (t[i] - t[j - 1]) * a[i].x - (sum[i] - sum[j - 1]) + a[i].c); f[i]=min(f[i],f[j−1]+(t[i]−t[j−1])∗a[i].x−(sum[i]−sum[j−1])+a[i].c); 大力 f[i]f[i]f[i] 在iii设立的最优方案。 x[i]&lt;=f[k−1]+s[k−1]−(f[j−1]+s[j−1]t[k−1]−t[j−1]x[i] &lt;= \frac{f[k - 1] + s[k - 1] - (f[j - 1] + s[j - 1] }{t[k - 1] - t[j - 1]}x[i]&lt;=t[k−1]−t[j−1]f[k−1]+s[k−1]−(f[j−1]+s[j−1]​ 维护凸包。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;bitset&gt;#define mk make_pair#define fi first#define nd second#define pii pair&lt;int,int&gt;#define pb push_back#define sqr(x) ((x)*(x))using namespace std;typedef long long ll;inline ll read() &#123;ll x = 0; char ch = getchar(), w = 1;while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') w = -1;ch = getchar();&#125;while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0';ch = getchar();&#125;return x * w;&#125;void write(ll x) &#123;if(x &lt; 0) putchar('-'), x = -x;if(x &gt; 9) write(x / 10);putchar(x % 10 + '0');&#125;inline void writeln(ll x) &#123;write(x);puts("");&#125;const int N = 2100000;struct node &#123; ll x, p, c;&#125;a[N];ll f[N], s[N], t[N];bool cmp(node x, node y) &#123; return x.x &lt; y.x;&#125;int q[N], head, tail;int n;double slop(int x, int y) &#123; return (double)(f[y - 1] + s[y - 1] - (f[x - 1] + s[x - 1])) / (t[y - 1] - t[x - 1]);&#125;int main() &#123; n = read(); for(int i = 1; i &lt;= n; ++i) a[i].x = read(), a[i].p = read(), a[i].c = read(); sort(a +1, a + 1 + n, cmp); for(int i = 1;i &lt;= n; ++i) s[i] = s[i - 1] + a[i].x * a[i].p, t[i] = t[i - 1] + a[i].p; head = 1; for(int i = 1; i &lt;= n; ++i) &#123; while(head &lt; tail &amp;&amp; slop(q[tail - 1], q[tail]) &gt;= slop(q[tail - 1], i))--tail; q[++tail] = i; while(head &lt; tail &amp;&amp; slop(q[head], q[head + 1]) &lt;= a[i].x) ++head; f[i] = f[q[head] - 1] - t[q[head] - 1] * a[i].x + s[q[head] - 1] + t[i] * a[i].x + a[i].c - s[i]; &#125; writeln(f[n]); return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ3240」[Noi2013]矩阵游戏]]></title>
    <url>%2Fpost%2F39ae0330.html</url>
    <content type="text"><![CDATA[Description F[1][1]=1F[1][1]=1 F[1][1]=1 F[i,j]=a∗F[i][j−1]+b(j!=1)F[i,j]=a*F[i][j-1]+b (j!=1) F[i,j]=a∗F[i][j−1]+b(j!=1) F[i,1]=c∗F[i−1][m]+d(i≠1)F[i,1]=c*F[i-1][m]+d (i\neq 1) F[i,1]=c∗F[i−1][m]+d(i≠1) 递推式中aaa,bbb,ccc,ddd都是给定的常数。 现在婷婷想知道F[n][m]F[n][m]F[n][m]的值是多少. Input 一行有六个整数nnn,mmm,aaa,bbb,ccc,ddd。意义如题所述 Output 包含一个整数，表示F[n][m]F[n][m]F[n][m]除以1,000,000,0071,000,000,0071,000,000,007的余数 Solution 矩阵乘法也是满足费马小定理的。 设矩阵从左到右转移是A1A_1A1​，从上到下转移是A2A_2A2​ 答案是就是A1(A1A2)n−1A_1(A_1A_2)^{n-1}A1​(A1​A2​)n−1 A1=[a0b1]A_1=\begin{bmatrix}a &amp; 0 \\b &amp; 1 \end{bmatrix}A1​=[ab​01​] A2=[c0d1]A_2=\begin{bmatrix}c &amp; 0 \\d &amp; 1 \end{bmatrix}A2​=[cd​01​] 初始矩阵T=[11]T=\begin{bmatrix}1 &amp; 1\end{bmatrix}T=[1​1​] a=1a=1a=1或者c=1c=1c=1要特判，因为转移变成线性了，那么费马小定理不适用，模数要等于ppp。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;bitset&gt;#define mk make_pair#define fi first#define nd second#define pii pair&lt;int,int&gt;#define pb push_back#define sqr(x) ((x)*(x))using namespace std;typedef long long ll;inline ll read() &#123;ll x = 0; char ch = getchar(), w = 1;while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') w = -1;ch = getchar();&#125;while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0';ch = getchar();&#125;return x * w;&#125;void write(ll x) &#123;if(x &lt; 0) putchar('-'), x = -x;if(x &gt; 9) write(x / 10);putchar(x % 10 + '0');&#125;inline void writeln(ll x) &#123;write(x);puts("");&#125;const ll p = 1000000007;const int N = 2000100;ll n, m ,a,b,c,d;inline ll ksm(ll x, ll y) &#123; ll res = 1; for(; y; y &gt;&gt;= 1, x = x * x % p) if(y &amp; 1) res = res * x %p; return res;&#125;char s1[N], s2[N];ll readl(char *s, ll Mod) &#123; int len = strlen(s + 1); ll res = 0; for(int i = 1; i &lt;= len; ++i) res = (res * 10 + s[i] - '0') % Mod; return res;&#125;struct Matrix &#123; ll a[3][3]; Matrix () &#123;memset(a,0,sizeof a);&#125; Matrix operator * (const Matrix b) &#123; Matrix c; memset(c.a, 0, sizeof c.a); for(int i = 0; i &lt; 2; ++i) for(int j = 0; j &lt; 2; ++j) for(int k = 0; k &lt; 2; ++k) c.a[i][j] += a[i][k] * b.a[k][j] % p; for(int i = 0; i &lt; 2; ++i) for(int j = 0; j &lt; 2; ++j) c.a[i][j] %= p; return c; &#125;&#125;t,a1,a2,res,tmp;Matrix ksm(Matrix x, ll y) &#123; y %= (p - 1); Matrix res; for(int i =0; i &lt; 2; ++i) res.a[i][i] = 1; for(; y; y &gt;&gt;= 1, x = x * x) if(y &amp; 1) res = res * x; return res;&#125;int main() &#123; scanf("%s%s",s1 + 1, s2 +1); a = read(), b = read(), c = read(), d = read(); if(c == 1) n = readl(s1, p); else n = readl(s1, p - 1); if(a == 1) m = readl(s2, p); else m = readl(s2, p - 1); t.a[0][0] = 1, t.a[0][1] = 1; a1.a[0][0] = a, a1.a[1][0] = b, a1.a[1][1] = 1; a2.a[0][0] = c, a2.a[1][0] = d, a2.a[1][1] = 1; tmp = a1; a1 = ksm(a1, m - 1 + p - 1); a1 = a1 * a2; a1 = ksm(a1, n - 1 + p - 1); a1 = a1 * ksm(tmp, m - 1 + p - 1); t = t * a1; writeln(t.a[0][0]); return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ2820」YY的GCD]]></title>
    <url>%2Fpost%2F79b569af.html</url>
    <content type="text"><![CDATA[Description 给定NNN, MMM,求1≤x≤N1\leq x\leq N1≤x≤N, 1≤y≤M1\leq y\leq M1≤y≤M且gcd(x,y)gcd(x, y)gcd(x,y)为质数的(x,y)(x, y)(x,y)有多少对。 Input 第一行一个整数TTT表述数据组数接下来TTT行，每行两个正整数，表示NNN,MMM。 Output TTT行，每行一个整数表示第iii组数据的结果 HINT T=10000T=10000T=10000 N,M≤10000000N,M\leq10000000N,M≤10000000 Solution 这题和「BZOJ2301」类似。 定义： F(p)F(p)F(p)表示p∣gcd(x,y)p|gcd(x,y)p∣gcd(x,y)的点对个数，其中p∈primep\in primep∈prime。 f(i)f(i)f(i)表示gcd(x,y)=igcd(x,y)=igcd(x,y)=i的点对个数。 F(p)=∑p∣df(d)F(p)=\sum_{p|d}f(d) F(p)=p∣d∑​f(d) 反演FFF函数可以得到 f(p)=∑p∣dμ(dp)F(d)f(p)=\sum_{p|d}\mu(\frac{d}{p})F(d) f(p)=p∣d∑​μ(pd​)F(d) 显然d=kp,k∈Nd=kp,k\in Nd=kp,k∈N Ans=∑p∑p∣dμ(dp)F(d)Ans=\sum_{p}\sum_{p|d}\mu(\frac{d}{p})F(d) Ans=p∑​p∣d∑​μ(pd​)F(d) 仔细考虑一下，对于每一个ddd，乘以∑p∣dμ(dp)\sum_{p|d}\mu(\frac{d}{p})∑p∣d​μ(pd​) 所以 Ans=∑dF(d)∑p∣dμ(dp)Ans=\sum_d F(d)\sum_{p|d}\mu(\frac{d}{p}) Ans=d∑​F(d)p∣d∑​μ(pd​) F(d)=⌊Nd⌋⌊Md⌋F(d)=\lfloor\frac{N}{d}\rfloor\lfloor\frac{M}{d}\rfloorF(d)=⌊dN​⌋⌊dM​⌋可以分块处理 ∑p∣dμ(dp)F(d)\sum_{p|d}\mu(\frac{d}{p})F(d)∑p∣d​μ(pd​)F(d)可以枚举质数ppp,然后去更新它的倍数。tottottot的个质数复杂度是∑pNNp\sum_{p}^{N}\frac{N}{p}∑pN​pN​ 大概是n÷ln(n)×(ln(n))2n\div ln(n)\times (ln(n))^2n÷ln(n)×(ln(n))2 我也不太会算。 加上分块，总的复杂度是O(Nlog⁡n+NT)O(N\log n+\sqrt{N}T)O(Nlogn+N​T) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;bitset&gt;#define mk make_pair#define fi first#define nd second#define pii pair&lt;int,int&gt;#define pb push_back#define sqr(x) ((x)*(x))using namespace std;typedef long long ll;inline ll read() &#123;ll x = 0; char ch = getchar(), w = 1;while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') w = -1;ch = getchar();&#125;while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0';ch = getchar();&#125;return x * w;&#125;void write(ll x) &#123;if(x &lt; 0) putchar('-'), x = -x;if(x &gt; 9) write(x / 10);putchar(x % 10 + '0');&#125;inline void writeln(ll x) &#123;write(x);puts("");&#125;const int N = 1e7 + 6;bool v[N];int mu[N],p[N], tot;ll s[N];void pre()&#123; mu[1] = 1; for(int i = 2; i &lt;= 1e7; ++i) &#123; if(!v[i]) mu[i] = -1, p[++tot] = i; for(int j = 1; j &lt;= tot &amp;&amp; i &lt;= 1e7/p[j]; ++j)&#123; v[i * p[j]] = 1; if(i % p[j] == 0) &#123; mu[i * p[j]] = 0; break; &#125; mu[i * p[j]] = -mu[i]; &#125; &#125; for(int i = 1; i &lt;= tot; ++i) for(int j = 1; j &lt;= 1e7 / p[i]; ++j) s[j * p[i]] += mu[j]; for(int i = 1; i &lt;= 1e7; ++i) s[i] += s[i - 1];&#125;int n, m;ll solve() &#123; ll res = 0;/* for(int i = 1; i &lt;= tot &amp;&amp; p[i] &lt;= min(n, m); ++i) &#123; for(int j = 1; j * p[i] &lt;= min(n, m); ++j) res += (ll)mu[j] * (n / (p[i] * j)) * (m / (p[i] * j)); &#125;*/ for(int i = 1, r; i &lt;= min(n, m); i = r +1) &#123; r = min(n / (n / i), m / (m / i)); res += (ll)(n / i) * (m / i) * (s[r] - s[i - 1]); &#125; return res; &#125;int main() &#123; int T = read(); pre(); while(T--) &#123; n = read(), m = read(); writeln(solve()); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ2301」[HAOI2011]Problem b]]></title>
    <url>%2Fpost%2F2c9e796c.html</url>
    <content type="text"><![CDATA[Description 对于给出的nnn个询问，每次求有多少个数对(x,y)(x,y)(x,y)，满足a≤x≤ba\leq x\leq ba≤x≤b，c≤y≤dc\leq y\leq dc≤y≤d，且gcd(x,y)=kgcd(x,y)=kgcd(x,y)=k，gcd(x,y)gcd(x,y)gcd(x,y)函数为xxx和yyy的最大公约数。 Input 第一行一个整数n，接下来n行每行五个整数，分别表示a、bbb、ccc、ddd、kkk Output 共nnn行，每行一个整数表示满足要求的数对(x,y)(x,y)(x,y)的个数 Solution f(i)f(i)f(i)表示x∈[1,n]x\in[1,n]x∈[1,n]，y∈[1,m]y\in[1,m]y∈[1,m]且gcd(x,y)=igcd(x,y)=igcd(x,y)=i的数对(x,y)(x,y)(x,y)数量 F(i)F(i)F(i)表示x∈[1,n]x\in[1,n]x∈[1,n]，y∈[1,m]y\in[1,m]y∈[1,m]且i∣gcd(x,y)i|gcd(x,y)i∣gcd(x,y)的数对(x,y(x,y(x,y数量 F(i)=∑i∣df(d)=⌊ni⌋⌊mi⌋F(i)=\sum_{i|d}f(d)=\lfloor\frac{n}{i}\rfloor\lfloor\frac{m}{i}\rfloor F(i)=i∣d∑​f(d)=⌊in​⌋⌊im​⌋ 反演FFF函数得到： f(i)=∑i∣dμ(di)F(d)=∑i∣dμ(di)⋅⌊nd⌋⌊md⌋f(i)=\sum_{i|d}\mu(\frac{d}{i})F(d)=\sum_{i|d}\mu(\frac{d}{i})\cdot \lfloor\frac{n}{d}\rfloor\lfloor\frac{m}{d}\rfloor f(i)=i∣d∑​μ(id​)F(d)=i∣d∑​μ(id​)⋅⌊dn​⌋⌊dm​⌋ O(50000n)O(50000n)O(50000n)还过不了题目，分块求后面部分就能达到优秀的O(nsqrt(50000))O(nsqrt(50000))O(nsqrt(50000)) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;bitset&gt;#define mk make_pair#define fi first#define nd second#define pii pair&lt;int,int&gt;#define pb push_back#define sqr(x) ((x)*(x))using namespace std;typedef long long ll;inline ll read() &#123;ll x = 0; char ch = getchar(), w = 1;while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') w = -1;ch = getchar();&#125;while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0';ch = getchar();&#125;return x * w;&#125;void write(ll x) &#123;if(x &lt; 0) putchar('-'), x = -x;if(x &gt; 9) write(x / 10);putchar(x % 10 + '0');&#125;inline void writeln(ll x) &#123;write(x);puts("");&#125;int k;const int N = 61000;int miu[N];bool v[N];int p[N], tot;void pre() &#123; miu[1] = 1; for(int i = 2; i &lt;= 50000; ++i) &#123; if(!v[i]) p[++tot] = i, miu[i] = -1; for(int j = 1; j &lt;= tot; ++j) &#123; if(p[j] &gt; 50000/ i) break; v[i * p[j]] = 1; if(i % p[j] == 0) &#123; miu[i * p[j]] = 0; break; &#125; miu[i * p[j]] = -miu[i]; &#125; &#125; for(int i = 1; i &lt;= 50000; ++i) miu[i] += miu[i - 1];&#125;ll solve(int n, int m) &#123; ll res = 0; /*for(int i = k; i &lt;= min(n, m); i += k) res += miu[i / k] * (n / i) * (m / i);*/ //printf("n=%d,m=%d\n",n,m); for(int i = 1, r; i * k &lt;= min(n, m); i = r + 1) &#123; r = min(n / (n / i), m / (m / i)); res += (ll)(miu[r] - miu[i - 1]) * (n / k / i) * (m / k / i); //printf("i=%d,r=%d,%d\n", i, r,(miu[r] - miu[i - 1]) * (n / i) * (m / i)); &#125; return res;&#125;int main() &#123; pre(); int T = read(); while(T--) &#123; int a = read(), b = read(), c = read(), d = read(); k = read(); writeln(solve(b,d) - solve(b, c - 1) - solve(a - 1, d) + solve(a - 1, c - 1)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>莫比乌斯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欧拉公式]]></title>
    <url>%2Fpost%2F9401e9ac.html</url>
    <content type="text"><![CDATA[欧拉公式 前言 今天博主在b站上看完了一个视频。此视频介绍了欧拉从定义π\piπ、以欧拉命名、伯努利发明的数eee、sinsinsin和coscoscos以及eie^iei、eee的泰勒展开式以及虚数iii。 最近几天要学FFTFFTFFT，这是一篇学习笔记希望能以新的角度审视数学，有错误的话，感谢评论里指出。 前置知识 幂法则 如果f(x)=xnf(x)=x^nf(x)=xn，那么f′(x)=nxn−1f&#x27;(x)=nx^{n-1}f′(x)=nxn−1 证明 新的函数值是f(x+dx)=(x+dx)n=(x+dx)(x+dx)(x+dx)⋯(x+dx)f(x+\mathrm{d}x)=(x+\mathrm{d}x)^n=(x+\mathrm{d}x)(x+\mathrm{d}x)(x+\mathrm{d}x)\cdots(x+\mathrm{d}x)f(x+dx)=(x+dx)n=(x+dx)(x+dx)(x+dx)⋯(x+dx) 可以由二项式定理得到 (x+dx)n=∑i=0n(in)xn−i(dx)i=(0n)xn+(1n)xn−1dx+(2n)xn−2(dx)2⋯(x+\mathrm{d}x)^n=\sum^{n}_{i=0}\left(\begin{array}{c}i\\ n\end{array}\right)x^{n-i}(\mathrm{d}x)^i=\left(\begin{array}{c}0\\ n\end{array}\right)x^n+\left(\begin{array}{c}1\\ n\end{array}\right)x^{n-1}\mathrm{d}x+\left(\begin{array}{c}2\\ n\end{array}\right)x^{n-2}(\mathrm{d}x)^2\cdots (x+dx)n=i=0∑n​(in​)xn−i(dx)i=(0n​)xn+(1n​)xn−1dx+(2n​)xn−2(dx)2⋯ df=f(x+dx)−f(x)=xn−1dx+xn−2(dx)2⋯df=f(x+\mathrm{d}x)-f(x)=x^{n-1}\mathrm{d}x+x^{n-2}(\mathrm{d}x)^2\cdots df=f(x+dx)−f(x)=xn−1dx+xn−2(dx)2⋯ dfdx=xn−1+n(n−1)2xn−2dx+n(n−1)(n−2)6xn−2dx⋯\frac{df}{dx}=x^{n-1}+\frac{n(n-1)}{2}x^{n-2}dx+\frac{n(n-1)(n-2)}{6}x^{n-2}dx\cdots dxdf​=xn−1+2n(n−1)​xn−2dx+6n(n−1)(n−2)​xn−2dx⋯ 因为dxdxdx趋向000,所以可以忽略含有dxdxdx的项,dfdx=xn−1\frac{df}{dx}=x^{n-1}dxdf​=xn−1 加法则 两个函数f(x)f(x)f(x)、g(x)g(x)g(x)，那么(f(x)+g(x))′=f′(x)+g′(x)(f(x)+g(x))&#x27;=f&#x27;(x)+g&#x27;(x)(f(x)+g(x))′=f′(x)+g′(x) 积法则 两个函数f(x)f(x)f(x)、g(x)g(x)g(x)，那么(f(x)g(x))′=f(x)g′(x)+f′(x)g(x)(f(x)g(x))&#x27;=f(x)g&#x27;(x)+f&#x27;(x)g(x)(f(x)g(x))′=f(x)g′(x)+f′(x)g(x) 证明 由于相乘想到面积来可视化过程，设一个矩形长宽分别为f(x)f(x)f(x)、g(x)g(x)g(x)，设h(x)=(f(x)g(x))′h(x)=(f(x)g(x))&#x27;h(x)=(f(x)g(x))′ 如图所示： 显然增加的面积就是三块有颜色面积的小矩形，绿红黄他们的面积之和为： f(x)d(g(x))+g(x)d(f(x))+d(f(x))d(g(x))=h′(x)dx⇒f(x)\mathrm{d}(g(x))+g(x)\mathrm{d}(f(x))+\mathrm{d}(f(x))\mathrm{d}(g(x))=h&#x27;(x)\mathrm{d}x\Rightarrow f(x)d(g(x))+g(x)d(f(x))+d(f(x))d(g(x))=h′(x)dx⇒ f(x)g′(x)dx+g(x)f′(x)dx+g′(x)dxf′(x)dx=h′(x)dxf(x)g&#x27;(x)\mathrm{d}x+g(x)f&#x27;(x)\mathrm{d}x+g&#x27;(x)\mathrm{d}xf&#x27;(x)\mathrm{d}x=h&#x27;(x)\mathrm{d}x f(x)g′(x)dx+g(x)f′(x)dx+g′(x)dxf′(x)dx=h′(x)dx 那么h′(x)dx=f(x)g′(x)+g(x)f′(x)+g′(x)f′(x)dx\frac{h&#x27;(x)}{dx}=f(x)g&#x27;(x)+g(x)f&#x27;(x)+g&#x27;(x)f&#x27;(x)\mathrm{d}xdxh′(x)​=f(x)g′(x)+g(x)f′(x)+g′(x)f′(x)dx 发现尾项与dx\mathrm{d}xdx有关，当dx\mathrm{d}xdx趋向000的时候可以忽略。 链式法则 两个函数f(x)f(x)f(x)、g(x)g(x)g(x)，那么f′(g(x))=f′(g(x))g′(x)f&#x27;(g(x))=f&#x27;(g(x))g&#x27;(x)f′(g(x))=f′(g(x))g′(x)，也就是dfdx=dfdgdgdx\frac{\mathrm{d}f}{\mathrm{d}x}=\frac{\mathrm{d}f}{\mathrm{d}g}\frac{\mathrm{d}g}{\mathrm{d}x}dxdf​=dgdf​dxdg​ 证明 当xxx变化量为dxdxdx的时候,ggg函数变化量是d(g(x))\mathrm{d}(g(x))d(g(x))。 fff函数的变化量为： d(f(g(x)))=f′(g(x))d(g(x))=f′(g(x))g′(x)dx⇒d(f(g(x))dx=f′(g(x))g′(x)\mathrm{d}(f(g(x)))=f&#x27;(g(x))\mathrm{d}(g(x))=f&#x27;(g(x))g&#x27;(x)\mathrm{d}x\Rightarrow \frac{\mathrm{d}(f(g(x))}{\mathrm{d}x}=f&#x27;(g(x))g&#x27;(x) d(f(g(x)))=f′(g(x))d(g(x))=f′(g(x))g′(x)dx⇒dxd(f(g(x))​=f′(g(x))g′(x) 最后一步是由导数的定义得来的。 通过幂法则、链式法则推到商法则 三角函数的导数 sin⁡′(x)=cos(x)\sin&#x27;(x)=cos(x)sin′(x)=cos(x) cos⁡′(x)=−sin(x)\cos&#x27;(x)=-sin(x)cos′(x)=−sin(x) 证明 高阶导数 f(n)(x)f^{(n)}(x)f(n)(x)指的是f(x)f(x)f(x)的nnn阶导数。我自己的理解：描述f(x)f(x)f(x)的变化函数是f′(x)f&#x27;(x)f′(x)，描述f′(x)f&#x27;(x)f′(x)的变化函数f′′(x)f&#x27;&#x27;(x)f′′(x)，也就是f(n)f^{(n)}f(n)的变化受到f(n+1)f^{(n+1)}f(n+1)的控制，如果控制f1f^1f1、f2f^2f2···他们的函数都相等，那么&quot;理论上&quot;这两个函数是相等的。下面泰勒级数就用到这个思想。 拓展（无关本文) 指数函数求导 尝试求导 M(t)=2tM(t)=2^tM(t)=2t dMdt=2t+dt−2tdt=2t(2dt−1dt)⎵dt→0\frac{\mathrm{d}M}{\mathrm{d}t}=\frac{2^{t+\mathrm{d}t}-2^t}{\mathrm{d}t}=2^t\underbrace{(\frac{2^{\mathrm{d}t}-1}{\mathrm{d}t})}_{dt\to0} dtdM​=dt2t+dt−2t​=2tdt→0(dt2dt−1​)​​ 2dt−1dt\frac{2^{\mathrm{d}t}-1}{\mathrm{d}t}dt2dt−1​趋向于一个常数0.69314718056⋯0.69314718056\cdots0.69314718056⋯ 同样函数M(t)=3tM(t)=3^tM(t)=3t同样的方法，后半部分将趋向于1.09861228867⋯1.09861228867\cdots1.09861228867⋯ M(t)=8t→2.07944154168⋯M(t)=8^t\to 2.07944154168\cdotsM(t)=8t→2.07944154168⋯ 1.09861228867⋯×3=2.07944154168⋯1.09861228867\cdots{\times3}=2.07944154168\cdots1.09861228867⋯×3=2.07944154168⋯ 从指数上8=238=2^38=23，说明这个常数是对于对某个数求对数函数得到的。 有没有哪个底数能是的这个系数为111呢？ 即(at)′=at(a^t)&#x27;=a^t(at)′=at？ e的出现 这个底数就是e=2.71828⋯e=2.71828\cdotse=2.71828⋯ a^x的导数 由上面得到(ax)′=axln⁡(a)(a^x)&#x27;=a^x\ln(a)(ax)′=axln(a) d(ect)dt=cect\frac{d(e^{ct})}{\mathrm{d}t}=ce^{ct}dtd(ect)​=cect，ccc是常数，由复合函数求导。 所有指数函数aaa写作eln⁡(2)e^{\ln(2)}eln(2) 代入上式得到：ax=eln⁡(a)ta^x=e^{\ln(a)t}ax=eln(a)t 隐函数求导 圆的方程式x2+y2=rx^2+y^2=rx2+y2=r，这很显然，如果我们要对它求导怎么办？此时输入一个xxx不一定输出一个yyy。很显然这个函数是可以求导的，也就是求(x,y)(x,y)(x,y)这个坐标的斜率。 泰勒级数 由来 一个函数可以写成f(x)=∑i=0naixi=a0+a1x1+a2x2+⋯f(x)=\sum^n_{i=0}{a_ix^i}=a_0+a_1x_1+a_2x_2+\cdotsf(x)=∑i=0n​ai​xi=a0​+a1​x1​+a2​x2​+⋯ 在高阶导数的时候说过，如果两个函数每一阶导数都相等，那么&quot;理论上&quot;两个函数是相等的。 因为我们有cos′(x)=−sin(x)cos&#x27;(x)=-sin(x)cos′(x)=−sin(x)、cos′′(x)=−cos(x)cos&#x27;&#x27;(x)=-cos(x)cos′′(x)=−cos(x)、cos′′′(x)=sin(x)cos&#x27;&#x27;&#x27;(x)=sin(x)cos′′′(x)=sin(x)、cos′′′′(x)=cos(x)cos&#x27;&#x27;&#x27;&#x27;(x)=cos(x)cos′′′′(x)=cos(x) 此后就是−sin(x)-sin(x)−sin(x)、−cos(x)-cos(x)−cos(x)、sin(x)sin(x)sin(x)、cos(x)cos(x)cos(x)循环，求导次数xxx，其xmod 4=1x \mod\ 4=1xmod 4=1,222,333,000的时候分别对应这四个。 cos(0)=1⇒f(x)=a0+∑i=1nai⋅0=a0=1cos(0)=1\Rightarrow f(x)=a_0+\sum_{i=1}^n{a_i\cdot0}=a_0=1cos(0)=1⇒f(x)=a0​+∑i=1n​ai​⋅0=a0​=1 cos′(0)=0⇒f′(x)=1⋅a1+∑i=2n(i−1)ai⋅0=1!⋅a1=0cos&#x27;(0)=0\Rightarrow f&#x27;(x)=1\cdot a_1+\sum_{i=2}^n{(i-1)a_i\cdot0}=1!\cdot a_1=0cos′(0)=0⇒f′(x)=1⋅a1​+∑i=2n​(i−1)ai​⋅0=1!⋅a1​=0 cos⁡′′(0)=−1⇒f′′(x)=1⋅2⋅a2+∑i=3n(i−1)⋅(i−2)ai=2!⋅a2=−1\cos&#x27;&#x27;(0)=-1\Rightarrow f&#x27;&#x27;(x)=1\cdot2\cdot a_2+\sum_{i=3}^n{(i-1)\cdot(i-2)a_i}=2!\cdot a_2=-1cos′′(0)=−1⇒f′′(x)=1⋅2⋅a2​+∑i=3n​(i−1)⋅(i−2)ai​=2!⋅a2​=−1 cos′′′(0)=0⇒f′′′(x)=1⋅2⋅3a3+∑i=4n(i−1)⋅(i−2)⋅(i−3)ai=3!⋅a3=0cos&#x27;&#x27;&#x27;(0)=0\Rightarrow f&#x27;&#x27;&#x27;(x)=1\cdot2\cdot3 a_3+\sum_{i=4}^n{(i-1)\cdot(i-2)\cdot(i-3)a_i}=3!\cdot a_3=0cos′′′(0)=0⇒f′′′(x)=1⋅2⋅3a3​+∑i=4n​(i−1)⋅(i−2)⋅(i−3)ai​=3!⋅a3​=0 cos′′′′(0)=1⇒f′′′′(x)=1⋅2⋅3⋅4a4+∑i=5n(i−1)⋅(i−2)⋅(i−3)⋅(i−4)ai=4!⋅a4=1cos&#x27;&#x27;&#x27;&#x27;(0)=1\Rightarrow f&#x27;&#x27;&#x27;&#x27;(x)=1\cdot2\cdot3\cdot4 a_4+\sum_{i=5}^n{(i-1)\cdot(i-2)\cdot(i-3)\cdot(i-4)a_i}=4!\cdot a_4=1cos′′′′(0)=1⇒f′′′′(x)=1⋅2⋅3⋅4a4​+∑i=5n​(i−1)⋅(i−2)⋅(i−3)⋅(i−4)ai​=4!⋅a4​=1 可以发现规律了，假设取了iii次导数，且有i=2ni=2ni=2n。 nnn是奇数有：i!⋅ai=−1⇒ai=−1i!i!\cdot a_i=-1\Rightarrow a_i=-\frac{1}{i!}i!⋅ai​=−1⇒ai​=−i!1​ nnn是偶数有：i!⋅ai=1⇒ai=1i!i!\cdot a_i=1\Rightarrow a_i=\frac{1}{i!}i!⋅ai​=1⇒ai​=i!1​ 也就是cos(x)=1−x22!+x44!−x66!+x48!−⋯cos(x)=1-\frac{x^2}{2!}+\frac{x^4}{4!}-\frac{x^6}{6!}+\frac{x^4}{8!}-\cdotscos(x)=1−2!x2​+4!x4​−6!x6​+8!x4​−⋯ 同样的思路可以证明sin⁡(x)=∑i=2n+1,n∈N∞(−1)nxii!=x−x33!+x55!−x77!+⋯\sin(x)=\sum^{\infty}_{i=2n+1,n\in N}{(-1)^n\frac{x^i}{i!}}=x-\frac{x^3}{3!}+\frac{x^5}{5!}-\frac{x^7}{7!}+\cdotssin(x)=∑i=2n+1,n∈N∞​(−1)ni!xi​=x−3!x3​+5!x5​−7!x7​+⋯ 证明ex=⋯e^x=\cdotsex=⋯比这更容易，根据定义(ex)′=ex(e^x)&#x27;=e^x(ex)′=ex，重复上述过程即可。 麦克劳林展开式 ex=∑i=0∞xii!=1+x11!+x22!+x33!+x44!+⋯e^x=\sum^\infty_{i=0}{\frac{x^i}{i!}}=1+\frac{x^1}{1!}+\frac{x^2}{2!}+\frac{x^3}{3!}+\frac{x^4}{4!}+\cdotsex=∑i=0∞​i!xi​=1+1!x1​+2!x2​+3!x3​+4!x4​+⋯ sin⁡(x)=∑i=2n+1,n∈N∞(−1)nxii!=x−x33!+x55!−x77!+⋯\sin(x)=\sum^{\infty}_{i=2n+1,n\in N}{(-1)^n\frac{x^i}{i!}}=x-\frac{x^3}{3!}+\frac{x^5}{5!}-\frac{x^7}{7!}+\cdotssin(x)=∑i=2n+1,n∈N∞​(−1)ni!xi​=x−3!x3​+5!x5​−7!x7​+⋯ cos⁡(x)=∑i=2n,n∈N∞(−1)nxii!=1−x22!+x44!−x66!+⋯\cos(x)=\sum^{\infty}_{i=2n,n\in N}(-1)^n\frac{x^i}{i!}=1-\frac{x^2}{2!}+\frac{x^4}{4!}-\frac{x^6}{6!}+\cdotscos(x)=∑i=2n,n∈N∞​(−1)ni!xi​=1−2!x2​+4!x4​−6!x6​+⋯ 本文正题 eix=1+(ix)11!+(ix)22!+(ix)33!+(ix)44!+(ix)55!=1+ix1!−x22!−ix33!+x44!+ix55!−⋯e^{ix}=1+\frac{(ix)^1}{1!}+\frac{(ix)^2}{2!}+\frac{(ix)^3}{3!}+\frac{(ix)^4}{4!}+\frac{(ix)^5}{5!}=1+\frac{ix}{1!}-\frac{x^2}{2!}-\frac{ix^3}{3!}+\frac{x^4}{4!}+\frac{ix^5}{5!}-\cdotseix=1+1!(ix)1​+2!(ix)2​+3!(ix)3​+4!(ix)4​+5!(ix)5​=1+1!ix​−2!x2​−3!ix3​+4!x4​+5!ix5​−⋯ 把带有iii的提出来有： eix=1−x22!+x44!−x66!+⋯+i(x−x33!+x55!−x77!)=cos(x)+i×sin(x)e^{ix}=1-\frac{x^2}{2!}+\frac{x^4}{4!}-\frac{x^6}{6!}+\cdots+i(x-\frac{x^3}{3!}+\frac{x^5}{5!}-\frac{x^7}{7!})=cos(x)+i\times sin(x)eix=1−2!x2​+4!x4​−6!x6​+⋯+i(x−3!x3​+5!x5​−7!x7​)=cos(x)+i×sin(x) 当x=πx=\pix=π的时候 eiπ=cos⁡(π)+i×sin⁡(π)=−1e^{i\pi}=\cos(\pi)+i\times \sin(\pi)=-1eiπ=cos(π)+i×sin(π)=−1 所以eiπ+1=0e^{i\pi}+1=0eiπ+1=0]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>欧拉公式</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
</search>
