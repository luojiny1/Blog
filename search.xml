<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[「BZOJ2653」middle]]></title>
    <url>%2Fpost%2Fa4ac2e13.html</url>
    <content type="text"><![CDATA[Description 数组sss左端点在[a,b][a,b][a,b]之间,右端点在[c,d][c,d][c,d]之间的所有子串中，最大的中位数。长度为nnn的数组bbb的中位数定义为b[⌈n2⌉]b[\lceil\frac{n}{2}\rceil]b[⌈2n​⌉] 其中a&lt;b&lt;c&lt;da&lt;b&lt;c&lt;da&lt;b&lt;c&lt;d。位置也从000开始标号。 Input 第一行序列长度nnn。接下来n行按顺序给出a中的数。 接下来一行QQQ。然后QQQ行每行a,b,c,da,b,c,da,b,c,d，我们令上个询问的答案是 x(如果这是第一个询问则x=0)。 令数组q={(a+x)%n,(b+x)%n,(c+x)%n,(d+x)%n}q=\{(a+x)\%n,(b+x)\%n,(c+x)\%n,(d+x)\%n\}q={(a+x)%n,(b+x)%n,(c+x)%n,(d+x)%n}。 将qqq从小到大排序之后，令真正的 要询问的a=q[0]a=q[0]a=q[0],b=q[1]b=q[1]b=q[1],c=q[2]c=q[2]c=q[2],d=q[3]d=q[3]d=q[3]。 输入保证满足条件。 第一行所谓“排过序”指的是从小到大排序！ n≤20000,Q≤25000n\leq 20000,Q\leq 25000n≤20000,Q≤25000 Output QQQ行依次给出询问的答案。 Sample Input 1234567891051703377852714510442243028096905631320645232133 1 0 22 3 1 43 1 4 Sample Output 123271451044271451044969056313 Solution 二分答案xxx 令ai=1a_i=1ai​=1若ai≥xai\ge xai≥x否则ai=−1ai=-1ai=−1 问题转变成sum[b+1,c−1]+sum[l,b]+sum[d,r]sum[b + 1,c - 1]+sum[l,b]+sum[d,r]sum[b+1,c−1]+sum[l,b]+sum[d,r]最大值，其中l∈[a,b],r∈[c,d]l\in[a,b],r\in[c,d]l∈[a,b],r∈[c,d] 对于每一种权值建立线段树，每个节点统计最大左边和最大右边以及区间的aia_iai​和。 rt[i−1]rt[i-1]rt[i−1]转移到rt[i]rt[i]rt[i] 显然就是所有ai=Vi−1a_i=V_i-1ai​=Vi​−1的位置都变成−1-1−1 但要注意，比如{2,3,3,3,3}\{2,3,3,3,3\}{2,3,3,3,3}在插入的时候要一段段插入。 xxx先插入{2}\{2\}{2}，再插入{3,3,3,3}\{3,3,3,3\}{3,3,3,3}。 代码里有两种一段段插入的方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#define mk make_pair#define fi first#define nd second#define pii pair&lt;int,int&gt;#define pb push_back#define sqr(x) ((x)*(x))using namespace std;typedef long long ll;inline ll read() &#123;ll x = 0; char ch = getchar(), w = 1;while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') w = -1;ch = getchar();&#125;while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0';ch = getchar();&#125;return x * w;&#125;void write(ll x) &#123;if(x &lt; 0) putchar('-'), x = -x;if(x &gt; 9) write(x / 10);putchar(x % 10 + '0');&#125;inline void writeln(ll x) &#123;write(x);puts("");&#125;const int N = 41000;int n;struct Node &#123; int v, i; bool operator &lt; (const Node &amp;rhs) const &#123; return v &lt; rhs.v; &#125;&#125;a[N];int b[N], tot,rt[N];struct Tree &#123; int l, r, lm, rm, s;&#125;t[N * 32];void up(int o) &#123; t[o].lm = max(t[t[o].l].lm, t[t[o].l].s + t[t[o].r].lm); t[o].rm = max(t[t[o].r].rm, t[t[o].r].s + t[t[o].l].rm); t[o].s = t[t[o].l].s + t[t[o].r].s;&#125;void build(int &amp;o, int L, int R) &#123; o = ++tot; if(L == R) &#123; t[o].lm = t[o].rm = t[o].s = 1; return; &#125; int mid = (L + R) &gt;&gt; 1; if(L &lt;= mid) build(t[o].l, L, mid); if(R &gt; mid) build(t[o].r, mid + 1, R); up(o);&#125;void insert(int pre, int &amp;o, int L, int R, int x) &#123; o = ++tot; t[o] = t[pre]; if(L == R) &#123; t[o].lm = t[o].rm = t[o].s = -1; return; &#125; int mid = (L + R) &gt;&gt; 1; if(x &lt;= mid)insert(t[pre].l, t[o].l, L, mid, x); else insert(t[pre].r, t[o].r, mid + 1, R, x); up(o);&#125;Tree query(int o, int L, int R, int l, int r) &#123; if(!o || l &gt; r) return (Tree)&#123;0,0,0,0,0&#125;; if(l &lt;= L &amp;&amp; r &gt;= R) return t[o]; int mid = (L + R) &gt;&gt; 1; if(r &lt;= mid) return query(t[o].l, L, mid, l, r); if(l &gt; mid) return query(t[o].r, mid + 1, R, l, r); Tree x = query(t[o].l, L, mid, l, r); Tree y = query(t[o].r, mid + 1, R, l, r); Tree z; z.s = x.s + y.s; z.lm = max(x.lm, x.s + y.lm); z.rm = max(y.rm, y.s + x.rm); return z;&#125;int get(int t, int *q) &#123; Tree x = query(rt[t], 1, n, q[1], q[2]); Tree y = query(rt[t], 1, n, q[0], q[1] - 1); Tree z = query(rt[t], 1, n, q[2] + 1, q[3]); return x.s + max(y.rm, 0) + max(z.lm,0);&#125;vector&lt;int&gt;c[N];int main() &#123; n = read(); for(int i = 1 ; i &lt;= n; ++i) a[i].v = read(), a[i].i = i, b[i] = a[i].v; *b = n; sort(b + 1, b + 1 + *b); *b = unique(b + 1, b + 1 + *b) - b - 1; for(int i = 1; i &lt;= n; ++i) a[i].v = lower_bound(b + 1, b + 1 + *b, a[i].v) - b, c[a[i].v].pb(i); sort(a + 1, a + 1 + n); build(rt[0], 1, n); a[n + 1].v = 1e9 + 2333; int p = n + 1;/* for(int i = 1; i &lt;= n; ++i) if(a[i].v != a[i - 1].v) &#123; //坑点啊 rt[a[i].v] = rt[a[i].v - 1]; while(p &lt; i) insert(rt[a[i].v], rt[a[i].v], 1, n, a[p].i), ++p; p = n + 1; if(a[p].v != a[i].v) p = i; &#125;*/ /* for(int i = 1; i &lt;= n; ++i) if(a[i].v != a[i - 1].v) &#123; if(i &gt; 1)insert(rt[a[i].v - 1], rt[a[i].v], 1, n, a[i - 1].i); // a[i - 1].i会等于1 else rt[a[i].v] = rt[a[i].v - 1]; while(p &lt; i - 1) insert(rt[a[i].v], rt[a[i].v], 1, n, a[p].i), ++p; p = i; &#125;*/ for(int i = 1; i &lt;= *b; ++i) &#123; //尽量想到去用vector rt[i] = rt[i - 1]; for(int j = c[i - 1].size() - 1;~j;--j) insert(rt[i], rt[i], 1, n, c[i-1][j]); &#125; int Q = read(); int q[4], ans = 0; while(Q--) &#123; for(int i = 0; i &lt; 4; ++i) q[i] = (read() + ans) % n + 1; sort(q, q + 4); int r = *b + 1, l = 1; while(r - l &gt; 1) &#123; int mid = (l + r) &gt;&gt; 1; if(get(mid, q) &gt;= 0) l = mid; else r = mid; &#125; writeln(ans = b[l]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>好题</category>
      </categories>
      <tags>
        <tag>主席树</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ1061」[Noi2008]志愿者招募]]></title>
    <url>%2Fpost%2Fb8495a27.html</url>
    <content type="text"><![CDATA[Description 第iii天至少需要AiA_iAi​个人在工作，每种人可以从sis_isi​工作到tit_iti​，并且会花费cic_ici​的代价。 问最少的花费满足可以条件。 Input 第一行包含两个整数NNN, MMM，表示完成项目的天数和可以招募的志愿者的种类。 接下来的一行中包含NNN个非负 整数，表示每天至少需要的志愿者人数。 接下来的MMM行中每行包含三个整数SiS_iSi​, TiT_iTi​, CiC_iCi​，含义如上文所述。为了 方便起见，我们可以认为每类志愿者的数量都是无限多的。 Output 仅包含一个整数，表示你所设计的最优方案的总费用。 Sample Input 123453 32 3 41 2 22 3 53 3 2 Sample Output 114 HINT 1≤N≤10001 \leq N \leq 10001≤N≤1000，1≤N1 \leq N1≤N，MMM ≤10000\leq 10000≤10000，题目中其他所涉及的数据均不超过231−12^{31}-1231−1。 Solution 流量平衡 X1−Y1=A1X_1-Y_1=A_1X1​−Y1​=A1​ X1+X2−Y2=A2X_1+X_2-Y_2=A_2X1​+X2​−Y2​=A2​ X2+X3−Y3=A3X_2+X_3-Y_3=A_3X2​+X3​−Y3​=A3​ 得到 A1−A0=X1−Y1A_1-A_0=X_1-Y_1A1​−A0​=X1​−Y1​ A2−A1=X2−Y2+Y1A_2-A_1=X_2-Y_2+Y_1A2​−A1​=X2​−Y2​+Y1​ A3−A2=X3−Y3+Y2−X1A_3-A_2=X_3-Y_3+Y_2-X_1A3​−A2​=X3​−Y3​+Y2​−X1​ At−A3=Y3−X2−X3A_t-A_3=Y_3-X_2-X_3At​−A3​=Y3​−X2​−X3​ 只要满足了这样的流量平衡，那么只要把一个个方程加回来就可以得到最上面的条件方程。 按照等式来构造网络流就行了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;bitset&gt;#define mk make_pair#define fi first#define nd second#define pii pair&lt;int,int&gt;#define pb push_back#define sqr(x) ((x)*(x))using namespace std;typedef long long ll;inline ll read() &#123;ll x = 0; char ch = getchar(), w = 1;while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') w = -1;ch = getchar();&#125;while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0';ch = getchar();&#125;return x * w;&#125;void write(ll x) &#123;if(x &lt; 0) putchar('-'), x = -x;if(x &gt; 9) write(x / 10);putchar(x % 10 + '0');&#125;inline void writeln(ll x) &#123;write(x);puts("");&#125;const int N = 3100, M = 3100 * 5 * 2;int n, m;const int inf = 1e8;struct Edge &#123; int u, v, c, f, nxt;&#125;e[M];int s, t;bool v[N];int d[N], head[N], en,pre[N], inc[N];void addedge(int x, int y, int c, int f) &#123; e[++en].u = x, e[en].v = y, e[en].nxt = head[x], head[x] = en, e[en].c = c, e[en].f = f; e[++en].u = y, e[en].v = x, e[en].nxt = head[y], head[y] = en, e[en].c = -c, e[en].f = 0;&#125;bool spfa() &#123; queue&lt;int&gt;q; memset(v, 0, sizeof v); memset(inc, 0x3f, sizeof inc); memset(d, 0x3f, sizeof d); d[s] = 0; q.push(s); while(!q.empty()) &#123; int x = q.front(); q.pop(); v[x] = 0; for(int i = head[x]; i; i = e[i].nxt) if(e[i].f)&#123; int y = e[i].v; if(d[y] &gt; d[x] + e[i].c) &#123; d[y] = d[x] + e[i].c; inc[y] = min(inc[x], e[i].f); pre[y] = i; if(!v[y]) v[y] = 1, q.push(y); &#125; &#125; &#125; return d[t] != 0x3f3f3f3f;&#125;ll maxflow() &#123; ll k = 0; while(spfa()) &#123; int x = t; ll res = 0; while(x != s) res += e[pre[x]].c, x = e[pre[x]].u; k += res * inc[t]; x = t; while(x != s) e[pre[x]].f -= inc[t], e[pre[x] ^ 1].f += inc[t],x = e[pre[x]].u; &#125; return k;&#125;int a[N], T[N];int main() &#123; en = 1; n = read(), m = read(); t = n + 2, s = n + 3; for(int i = 1; i &lt;= n; ++i) a[i] = read(); for(int i = 1; i &lt;= m; ++i) &#123; int x = read(), y = read(), c = read(); addedge(y + 1, x, c, inf); &#125; for(int i = 1; i &lt; n + 1; ++i) addedge(i, i + 1, 0, inf); for(int i = 1; i &lt;= n + 1; ++i) &#123; int d = a[i] - a[i - 1]; if(d &gt; 0) addedge(i, t, 0, d); else addedge(s, i, 0, -d); &#125; writeln(maxflow()); return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>有上下界网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pólya定理学习笔记]]></title>
    <url>%2Fpost%2F393dafff.html</url>
    <content type="text"><![CDATA[定义 置换群 置换群的元素是置换，运算是置换的连接。 置换群是置换的一个集合。 置换一般形式是 (a1b1a2b2a3b3a4b4)\left(\begin{array}{c}a_1\\ b_1\end{array} \begin{array}{c}a_2\\ b_2\end{array} \begin{array}{c}a_3\\ b_3\end{array} \begin{array}{c}a_4\\ b_4\end{array} \right)(a1​b1​​a2​b2​​a3​b3​​a4​b4​​) 其中aaa、bbb分别是1→n1\to n1→n的一个排列。 每一列表示位置为aia_iai​的元素移动到bib_ibi​。 例如： (13213244)(14233241)=(13213244)(14233241)=(12243341)\left(\begin{array}{c}1\\ 3\end{array} \begin{array}{c}2\\ 1\end{array} \begin{array}{c}3\\ 2\end{array} \begin{array}{c}4\\ 4\end{array} \right) \left(\begin{array}{c}1\\ 4\end{array} \begin{array}{c}2\\ 3\end{array} \begin{array}{c}3\\ 2\end{array} \begin{array}{c}4\\ 1\end{array} \right)= \left(\begin{array}{c}1\\ 3\end{array} \begin{array}{c}2\\ 1\end{array} \begin{array}{c}3\\ 2\end{array} \begin{array}{c}4\\ 4\end{array} \right) \left(\begin{array}{c}1\\ 4\end{array} \begin{array}{c}2\\ 3\end{array} \begin{array}{c}3\\ 2\end{array} \begin{array}{c}4\\ 1\end{array} \right) =\left(\begin{array}{c}1\\ 2\end{array} \begin{array}{c}2\\ 4\end{array} \begin{array}{c}3\\ 3\end{array} \begin{array}{c}4\\ 1\end{array} \right) (13​21​32​44​)(14​23​32​41​)=(13​21​32​44​)(14​23​32​41​)=(12​24​33​41​) Burnside引理 例题 将一个正方形分成444格，每个格子可以染成黑色或者白色，有多少种方案？经过旋转得到相同的图像算一种。 内容 BurnsidBurnsidBurnsid引理是群论中的一个结论，在组合数学中可用于计算等价类的个数，常用于PolyaPolyaPolya计数。 BurnsidBurnsidBurnsid引理：用D(aj)D(a_j)D(aj​)表示在置换aja_jaj​下不变的元素的个数。LLL表示本质不同的方案数。 L=1∣G∣∑j=1nD(aj)L=\frac{1}{|G|}\sum_{j=1}^nD(a_j) L=∣G∣1​j=1∑n​D(aj​) 其中置换群G={G=\{G={转90∘90^\circ90∘,转180∘180^\circ180∘,转270∘270^\circ270∘ }\}} 把正方形的格子编号为 1423\begin{array}{c}1\\ 4\end{array}\begin{array}{c}2\\ 3\end{array} 14​23​ 转000度：]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>Polya</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「POJ2409」Let it Bead]]></title>
    <url>%2Fpost%2Fea82696f.html</url>
    <content type="text"><![CDATA[Description 项链由nnn个珠子组成，每个珠子可以染成ccc种不同的颜色，试求出一共可以设计出多少种本质不同的项链。 Solution 每个珠子顺指针旋转xxx布，可以证明循环节的个数有gcd(x,n)gcd(x,n)gcd(x,n)个。 假设当前位置是ppp,那么他的循环是ppp、p+xp+xp+x、⋯\cdots⋯、 p+kxp+kxp+kx 就是p+kx≡p(modn)p+kx\equiv p\pmod{n}p+kx≡p(modn) →\to→ kx≡0(modn)kx\equiv 0\pmod{n}kx≡0(modn) 我们要的是kkk的最小正整数解 n∣kxn|kx n∣kx 同时 x∣kxx|kx x∣kx 所以kx=lcm(x,n)kx=lcm(x,n)kx=lcm(x,n) ⇒\Rightarrow⇒ k=xn÷gcd(x,n)÷x=ngcd(x,n)k=xn\div gcd(x,n)\div x=\frac{n}{gcd(x,n)}k=xn÷gcd(x,n)÷x=gcd(x,n)n​ 那么p+1p+1p+1、p+2p+2p+2直到p+x−1p+x-1p+x−1都是可以独立成为一个循环节。 所以枚举一个循环长度xxx，那么它的循环节长度为gcd(x,n)gcd(x,n)gcd(x,n)。即 ∑x=1ncgcd(x,n)\sum_{x=1}^{n}c^{gcd(x,n)} x=1∑n​cgcd(x,n) 至此，循环的置换可以解决了，那么翻转的。 nnn是奇数 对于一个位置ppp，以ppp和圆心作对称轴，那么其他每一个点除了ppp点，都有一个对应的，这个每个置换的循环节个数为n+12\frac{n+1}{2}2n+1​ 共nnn个置换 nnn是偶数 一种是以ppp和p+n2p+\frac{n}{2}p+2n​作作对称轴，那么每个置换有n2+1\frac{n}{2}+12n​+1个循环，n/2n/2n/2个置换 一种是以某两个珠子的中点过圆心的情况，那么每个置换有n2\frac{n}{2}2n​个循环。共n−1n-1n−1个，共n/2n/2n/2个置换 根据Pólya定理，把两部分加起来除以置换的个数就可以了 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;cmath&gt;#include&lt;bitset&gt;#define mk make_pair#define fi first#define nd second#define pii pair&lt;int,int&gt;#define pb push_back#define sqr(x) ((x)*(x))using namespace std;typedef long long ll;inline ll read() &#123;ll x = 0; char ch = getchar(), w = 1;while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') w = -1;ch = getchar();&#125;while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0';ch = getchar();&#125;return x * w;&#125;void write(ll x) &#123;if(x &lt; 0) putchar('-'), x = -x;if(x &gt; 9) write(x / 10);putchar(x % 10 + '0');&#125;inline void writeln(ll x) &#123;write(x);puts("");&#125;int c, n;int gcd(int x, int y) &#123; if(!y) return x; return gcd(y, x % y);&#125;int main() &#123; while(1) &#123; c = read(), n = read(); if(!c &amp;&amp; !n) break; ll ans = 0; for(int i = 1; i &lt;= n; ++i) ans += pow(c, gcd(i, n)); if(n &amp; 1) ans += pow(c, n / 2 + 1) * (ll)n; else &#123; ans += (n / 2) * pow(c, n / 2 + 1); ans += (n / 2) * pow(c, n / 2); &#125; writeln(ans / (2 * n)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>Ploya</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ1096」[ZJOI2007]仓库建设]]></title>
    <url>%2Fpost%2F365bcb26.html</url>
    <content type="text"><![CDATA[Description 有nnn个工厂，每个工厂只能向编号更大的运输产品。每个工厂运输一件产品一单位距离的费用是111。每个工厂可以花费CiC_iCi​单位修建一个无限容量的仓库，且每个工厂有pip_ipi​个产品。问将所有产品放入仓库的最小费用(建造费用+运输费用） Input 第一行包含一个整数N，表示工厂的个数。接下来N行每行包含三个整数XiX_iXi​, PiP_iPi​, CiC_iCi​, 意义如题中所述。 Output 仅包含一个整数，为可以找到最优方案的费用。 Solution 斜率优化 可以写出暴力方程: f[i]=min⁡(f[i],f[j−1]+(t[i]−t[j−1])∗a[i].x−(sum[i]−sum[j−1])+a[i].c);f[i] = \min(f[i], f[j - 1] + (t[i] - t[j - 1]) * a[i].x - (sum[i] - sum[j - 1]) + a[i].c); f[i]=min(f[i],f[j−1]+(t[i]−t[j−1])∗a[i].x−(sum[i]−sum[j−1])+a[i].c); 大力 f[i]f[i]f[i] 在iii设立的最优方案。 x[i]&lt;=f[k−1]+s[k−1]−(f[j−1]+s[j−1]t[k−1]−t[j−1]x[i] &lt;= \frac{f[k - 1] + s[k - 1] - (f[j - 1] + s[j - 1] }{t[k - 1] - t[j - 1]}x[i]&lt;=t[k−1]−t[j−1]f[k−1]+s[k−1]−(f[j−1]+s[j−1]​ 维护凸包。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;bitset&gt;#define mk make_pair#define fi first#define nd second#define pii pair&lt;int,int&gt;#define pb push_back#define sqr(x) ((x)*(x))using namespace std;typedef long long ll;inline ll read() &#123;ll x = 0; char ch = getchar(), w = 1;while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') w = -1;ch = getchar();&#125;while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0';ch = getchar();&#125;return x * w;&#125;void write(ll x) &#123;if(x &lt; 0) putchar('-'), x = -x;if(x &gt; 9) write(x / 10);putchar(x % 10 + '0');&#125;inline void writeln(ll x) &#123;write(x);puts("");&#125;const int N = 2100000;struct node &#123; ll x, p, c;&#125;a[N];ll f[N], s[N], t[N];bool cmp(node x, node y) &#123; return x.x &lt; y.x;&#125;int q[N], head, tail;int n;double slop(int x, int y) &#123; return (double)(f[y - 1] + s[y - 1] - (f[x - 1] + s[x - 1])) / (t[y - 1] - t[x - 1]);&#125;int main() &#123; n = read(); for(int i = 1; i &lt;= n; ++i) a[i].x = read(), a[i].p = read(), a[i].c = read(); sort(a +1, a + 1 + n, cmp); for(int i = 1;i &lt;= n; ++i) s[i] = s[i - 1] + a[i].x * a[i].p, t[i] = t[i - 1] + a[i].p; head = 1; for(int i = 1; i &lt;= n; ++i) &#123; while(head &lt; tail &amp;&amp; slop(q[tail - 1], q[tail]) &gt;= slop(q[tail - 1], i))--tail; q[++tail] = i; while(head &lt; tail &amp;&amp; slop(q[head], q[head + 1]) &lt;= a[i].x) ++head; f[i] = f[q[head] - 1] - t[q[head] - 1] * a[i].x + s[q[head] - 1] + t[i] * a[i].x + a[i].c - s[i]; &#125; writeln(f[n]); return 0;&#125;]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ3240」[Noi2013]矩阵游戏]]></title>
    <url>%2Fpost%2F39ae0330.html</url>
    <content type="text"><![CDATA[Description F[1][1]=1F[1][1]=1 F[1][1]=1 F[i,j]=a∗F[i][j−1]+b(j!=1)F[i,j]=a*F[i][j-1]+b (j!=1) F[i,j]=a∗F[i][j−1]+b(j!=1) F[i,1]=c∗F[i−1][m]+d(i≠1)F[i,1]=c*F[i-1][m]+d (i\neq 1) F[i,1]=c∗F[i−1][m]+d(i≠1) 递推式中aaa,bbb,ccc,ddd都是给定的常数。 现在婷婷想知道F[n][m]F[n][m]F[n][m]的值是多少. Input 一行有六个整数nnn,mmm,aaa,bbb,ccc,ddd。意义如题所述 Output 包含一个整数，表示F[n][m]F[n][m]F[n][m]除以1,000,000,0071,000,000,0071,000,000,007的余数 Solution 矩阵乘法也是满足费马小定理的。 设矩阵从左到右转移是A1A_1A1​，从上到下转移是A2A_2A2​ 答案是就是A1(A1A2)n−1A_1(A_1A_2)^{n-1}A1​(A1​A2​)n−1 A1=[a0b1]A_1=\begin{bmatrix}a &amp; 0 \\b &amp; 1 \end{bmatrix}A1​=[ab​01​] A2=[c0d1]A_2=\begin{bmatrix}c &amp; 0 \\d &amp; 1 \end{bmatrix}A2​=[cd​01​] 初始矩阵T=[11]T=\begin{bmatrix}1 &amp; 1\end{bmatrix}T=[1​1​] a=1a=1a=1或者c=1c=1c=1要特判，因为转移变成线性了，那么费马小定理不适用，模数要等于ppp。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;bitset&gt;#define mk make_pair#define fi first#define nd second#define pii pair&lt;int,int&gt;#define pb push_back#define sqr(x) ((x)*(x))using namespace std;typedef long long ll;inline ll read() &#123;ll x = 0; char ch = getchar(), w = 1;while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') w = -1;ch = getchar();&#125;while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0';ch = getchar();&#125;return x * w;&#125;void write(ll x) &#123;if(x &lt; 0) putchar('-'), x = -x;if(x &gt; 9) write(x / 10);putchar(x % 10 + '0');&#125;inline void writeln(ll x) &#123;write(x);puts("");&#125;const ll p = 1000000007;const int N = 2000100;ll n, m ,a,b,c,d;inline ll ksm(ll x, ll y) &#123; ll res = 1; for(; y; y &gt;&gt;= 1, x = x * x % p) if(y &amp; 1) res = res * x %p; return res;&#125;char s1[N], s2[N];ll readl(char *s, ll Mod) &#123; int len = strlen(s + 1); ll res = 0; for(int i = 1; i &lt;= len; ++i) res = (res * 10 + s[i] - '0') % Mod; return res;&#125;struct Matrix &#123; ll a[3][3]; Matrix () &#123;memset(a,0,sizeof a);&#125; Matrix operator * (const Matrix b) &#123; Matrix c; memset(c.a, 0, sizeof c.a); for(int i = 0; i &lt; 2; ++i) for(int j = 0; j &lt; 2; ++j) for(int k = 0; k &lt; 2; ++k) c.a[i][j] += a[i][k] * b.a[k][j] % p; for(int i = 0; i &lt; 2; ++i) for(int j = 0; j &lt; 2; ++j) c.a[i][j] %= p; return c; &#125;&#125;t,a1,a2,res,tmp;Matrix ksm(Matrix x, ll y) &#123; y %= (p - 1); Matrix res; for(int i =0; i &lt; 2; ++i) res.a[i][i] = 1; for(; y; y &gt;&gt;= 1, x = x * x) if(y &amp; 1) res = res * x; return res;&#125;int main() &#123; scanf("%s%s",s1 + 1, s2 +1); a = read(), b = read(), c = read(), d = read(); if(c == 1) n = readl(s1, p); else n = readl(s1, p - 1); if(a == 1) m = readl(s2, p); else m = readl(s2, p - 1); t.a[0][0] = 1, t.a[0][1] = 1; a1.a[0][0] = a, a1.a[1][0] = b, a1.a[1][1] = 1; a2.a[0][0] = c, a2.a[1][0] = d, a2.a[1][1] = 1; tmp = a1; a1 = ksm(a1, m - 1 + p - 1); a1 = a1 * a2; a1 = ksm(a1, n - 1 + p - 1); a1 = a1 * ksm(tmp, m - 1 + p - 1); t = t * a1; writeln(t.a[0][0]); return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ2820」YY的GCD]]></title>
    <url>%2Fpost%2F79b569af.html</url>
    <content type="text"><![CDATA[Description 给定NNN, MMM,求1≤x≤N1\leq x\leq N1≤x≤N, 1≤y≤M1\leq y\leq M1≤y≤M且gcd(x,y)gcd(x, y)gcd(x,y)为质数的(x,y)(x, y)(x,y)有多少对。 Input 第一行一个整数TTT表述数据组数接下来TTT行，每行两个正整数，表示NNN,MMM。 Output TTT行，每行一个整数表示第iii组数据的结果 HINT T=10000T=10000T=10000 N,M≤10000000N,M\leq10000000N,M≤10000000 Solution 这题和「BZOJ2301」类似。 定义： F(p)F(p)F(p)表示p∣gcd(x,y)p|gcd(x,y)p∣gcd(x,y)的点对个数，其中p∈primep\in primep∈prime。 f(i)f(i)f(i)表示gcd(x,y)=igcd(x,y)=igcd(x,y)=i的点对个数。 F(p)=∑p∣df(d)F(p)=\sum_{p|d}f(d) F(p)=p∣d∑​f(d) 反演FFF函数可以得到 f(p)=∑p∣dμ(dp)F(d)f(p)=\sum_{p|d}\mu(\frac{d}{p})F(d) f(p)=p∣d∑​μ(pd​)F(d) 显然d=kp,k∈Nd=kp,k\in Nd=kp,k∈N Ans=∑p∑p∣dμ(dp)F(d)Ans=\sum_{p}\sum_{p|d}\mu(\frac{d}{p})F(d) Ans=p∑​p∣d∑​μ(pd​)F(d) 仔细考虑一下，对于每一个ddd，乘以∑p∣dμ(dp)\sum_{p|d}\mu(\frac{d}{p})∑p∣d​μ(pd​) 所以 Ans=∑dF(d)∑p∣dμ(dp)Ans=\sum_d F(d)\sum_{p|d}\mu(\frac{d}{p}) Ans=d∑​F(d)p∣d∑​μ(pd​) F(d)=⌊Nd⌋⌊Md⌋F(d)=\lfloor\frac{N}{d}\rfloor\lfloor\frac{M}{d}\rfloorF(d)=⌊dN​⌋⌊dM​⌋可以分块处理 ∑p∣dμ(dp)F(d)\sum_{p|d}\mu(\frac{d}{p})F(d)∑p∣d​μ(pd​)F(d)可以枚举质数ppp,然后去更新它的倍数。tottottot的个质数复杂度是∑pNNp\sum_{p}^{N}\frac{N}{p}∑pN​pN​ 大概是n÷ln(n)×(ln(n))2n\div ln(n)\times (ln(n))^2n÷ln(n)×(ln(n))2 我也不太会算。 加上分块，总的复杂度是O(Nlog⁡n+NT)O(N\log n+\sqrt{N}T)O(Nlogn+N​T) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;bitset&gt;#define mk make_pair#define fi first#define nd second#define pii pair&lt;int,int&gt;#define pb push_back#define sqr(x) ((x)*(x))using namespace std;typedef long long ll;inline ll read() &#123;ll x = 0; char ch = getchar(), w = 1;while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') w = -1;ch = getchar();&#125;while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0';ch = getchar();&#125;return x * w;&#125;void write(ll x) &#123;if(x &lt; 0) putchar('-'), x = -x;if(x &gt; 9) write(x / 10);putchar(x % 10 + '0');&#125;inline void writeln(ll x) &#123;write(x);puts("");&#125;const int N = 1e7 + 6;bool v[N];int mu[N],p[N], tot;ll s[N];void pre()&#123; mu[1] = 1; for(int i = 2; i &lt;= 1e7; ++i) &#123; if(!v[i]) mu[i] = -1, p[++tot] = i; for(int j = 1; j &lt;= tot &amp;&amp; i &lt;= 1e7/p[j]; ++j)&#123; v[i * p[j]] = 1; if(i % p[j] == 0) &#123; mu[i * p[j]] = 0; break; &#125; mu[i * p[j]] = -mu[i]; &#125; &#125; for(int i = 1; i &lt;= tot; ++i) for(int j = 1; j &lt;= 1e7 / p[i]; ++j) s[j * p[i]] += mu[j]; for(int i = 1; i &lt;= 1e7; ++i) s[i] += s[i - 1];&#125;int n, m;ll solve() &#123; ll res = 0;/* for(int i = 1; i &lt;= tot &amp;&amp; p[i] &lt;= min(n, m); ++i) &#123; for(int j = 1; j * p[i] &lt;= min(n, m); ++j) res += (ll)mu[j] * (n / (p[i] * j)) * (m / (p[i] * j)); &#125;*/ for(int i = 1, r; i &lt;= min(n, m); i = r +1) &#123; r = min(n / (n / i), m / (m / i)); res += (ll)(n / i) * (m / i) * (s[r] - s[i - 1]); &#125; return res; &#125;int main() &#123; int T = read(); pre(); while(T--) &#123; n = read(), m = read(); writeln(solve()); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ2301」[HAOI2011]Problem b]]></title>
    <url>%2Fpost%2F2c9e796c.html</url>
    <content type="text"><![CDATA[Description 对于给出的nnn个询问，每次求有多少个数对(x,y)(x,y)(x,y)，满足a≤x≤ba\leq x\leq ba≤x≤b，c≤y≤dc\leq y\leq dc≤y≤d，且gcd(x,y)=kgcd(x,y)=kgcd(x,y)=k，gcd(x,y)gcd(x,y)gcd(x,y)函数为xxx和yyy的最大公约数。 Input 第一行一个整数n，接下来n行每行五个整数，分别表示a、bbb、ccc、ddd、kkk Output 共nnn行，每行一个整数表示满足要求的数对(x,y)(x,y)(x,y)的个数 Solution f(i)f(i)f(i)表示x∈[1,n]x\in[1,n]x∈[1,n]，y∈[1,m]y\in[1,m]y∈[1,m]且gcd(x,y)=igcd(x,y)=igcd(x,y)=i的数对(x,y)(x,y)(x,y)数量 F(i)F(i)F(i)表示x∈[1,n]x\in[1,n]x∈[1,n]，y∈[1,m]y\in[1,m]y∈[1,m]且i∣gcd(x,y)i|gcd(x,y)i∣gcd(x,y)的数对(x,y(x,y(x,y数量 F(i)=∑i∣df(d)=⌊ni⌋⌊mi⌋F(i)=\sum_{i|d}f(d)=\lfloor\frac{n}{i}\rfloor\lfloor\frac{m}{i}\rfloor F(i)=i∣d∑​f(d)=⌊in​⌋⌊im​⌋ 反演FFF函数得到： f(i)=∑i∣dμ(di)F(d)=∑i∣dμ(di)⋅⌊nd⌋⌊md⌋f(i)=\sum_{i|d}\mu(\frac{d}{i})F(d)=\sum_{i|d}\mu(\frac{d}{i})\cdot \lfloor\frac{n}{d}\rfloor\lfloor\frac{m}{d}\rfloor f(i)=i∣d∑​μ(id​)F(d)=i∣d∑​μ(id​)⋅⌊dn​⌋⌊dm​⌋ O(50000n)O(50000n)O(50000n)还过不了题目，分块求后面部分就能达到优秀的O(nsqrt(50000))O(nsqrt(50000))O(nsqrt(50000)) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;bitset&gt;#define mk make_pair#define fi first#define nd second#define pii pair&lt;int,int&gt;#define pb push_back#define sqr(x) ((x)*(x))using namespace std;typedef long long ll;inline ll read() &#123;ll x = 0; char ch = getchar(), w = 1;while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') w = -1;ch = getchar();&#125;while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0';ch = getchar();&#125;return x * w;&#125;void write(ll x) &#123;if(x &lt; 0) putchar('-'), x = -x;if(x &gt; 9) write(x / 10);putchar(x % 10 + '0');&#125;inline void writeln(ll x) &#123;write(x);puts("");&#125;int k;const int N = 61000;int miu[N];bool v[N];int p[N], tot;void pre() &#123; miu[1] = 1; for(int i = 2; i &lt;= 50000; ++i) &#123; if(!v[i]) p[++tot] = i, miu[i] = -1; for(int j = 1; j &lt;= tot; ++j) &#123; if(p[j] &gt; 50000/ i) break; v[i * p[j]] = 1; if(i % p[j] == 0) &#123; miu[i * p[j]] = 0; break; &#125; miu[i * p[j]] = -miu[i]; &#125; &#125; for(int i = 1; i &lt;= 50000; ++i) miu[i] += miu[i - 1];&#125;ll solve(int n, int m) &#123; ll res = 0; /*for(int i = k; i &lt;= min(n, m); i += k) res += miu[i / k] * (n / i) * (m / i);*/ //printf("n=%d,m=%d\n",n,m); for(int i = 1, r; i * k &lt;= min(n, m); i = r + 1) &#123; r = min(n / (n / i), m / (m / i)); res += (ll)(miu[r] - miu[i - 1]) * (n / k / i) * (m / k / i); //printf("i=%d,r=%d,%d\n", i, r,(miu[r] - miu[i - 1]) * (n / i) * (m / i)); &#125; return res;&#125;int main() &#123; pre(); int T = read(); while(T--) &#123; int a = read(), b = read(), c = read(), d = read(); k = read(); writeln(solve(b,d) - solve(b, c - 1) - solve(a - 1, d) + solve(a - 1, c - 1)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>莫比乌斯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欧拉公式——震惊！小学生也会证？]]></title>
    <url>%2Fpost%2F9401e9ac.html</url>
    <content type="text"><![CDATA[欧拉公式（未完待续） 前言 今天博主在b站上看完了一个视频。此视频介绍了欧拉从定义π\piπ、以欧拉命名、伯努利发明的数eee、sinsinsin和coscoscos以及eie^iei、eee的泰勒展开式以及虚数iii。 主要是因为最近几天要学FFTFFTFFT，这是一篇学习笔记，有错误的话，感谢评论里指出。 前置知识 幂法则 如果f(x)=xnf(x)=x^nf(x)=xn，那么f′(x)=nxn−1f&#x27;(x)=nx^{n-1}f′(x)=nxn−1 证明 加法则 两个函数f(x)f(x)f(x)、g(x)g(x)g(x)，那么(f(x)+g(x))′=f′(x)+g′(x)(f(x)+g(x))&#x27;=f&#x27;(x)+g&#x27;(x)(f(x)+g(x))′=f′(x)+g′(x) 积法则 两个函数f(x)f(x)f(x)、g(x)g(x)g(x)，那么(f(x)g(x))′=f(x)g′(x)+f′(x)g(x)(f(x)g(x))&#x27;=f(x)g&#x27;(x)+f&#x27;(x)g(x)(f(x)g(x))′=f(x)g′(x)+f′(x)g(x) 证明 链式法则 两个函数f(x)f(x)f(x)、g(x)g(x)g(x)，那么f′(g(x))=g′(f(x))g′(x)f&#x27;(g(x))=g&#x27;(f(x))g&#x27;(x)f′(g(x))=g′(f(x))g′(x)，也就是dfdx=dfdgdgdx\frac{\mathrm{d}f}{\mathrm{d}x}=\frac{\mathrm{d}f}{\mathrm{d}g}\frac{\mathrm{d}g}{\mathrm{d}x}dxdf​=dgdf​dxdg​ 证明 通过幂法则、链式法则推到商法则 三角函数的导数 sin⁡′(x)=cos(x)\sin&#x27;(x)=cos(x)sin′(x)=cos(x) cos⁡′(x)=−sin(x)\cos&#x27;(x)=-sin(x)cos′(x)=−sin(x) 证明 高阶导数 f(n)(x)f^{(n)}(x)f(n)(x)指的是f(x)f(x)f(x)的nnn阶导数。我自己的理解：描述f(x)f(x)f(x)的变化函数是f′(x)f&#x27;(x)f′(x)，描述f′(x)f&#x27;(x)f′(x)的变化函数f′′(x)f&#x27;&#x27;(x)f′′(x)，也就是f(n)f^{(n)}f(n)的变化受到f(n+1)f^{(n+1)}f(n+1)的控制，如果控制f1f^1f1、f2f^2f2···他们的函数都相等，那么&quot;理论上&quot;这两个函数是相等的。下面泰勒级数就用到这个思想。 拓展（无关本文) 指数函数求导 尝试求导 e的出现 a^x的导数 (ax)′=ln⁡(a)ax(a^x)&#x27;=\ln(a)a^x(ax)′=ln(a)ax 隐函数求导 圆的方程式x2+y2=rx^2+y^2=rx2+y2=r，这很显然，如果我们要对它求导怎么办？此时输入一个xxx不一定输出一个yyy。很显然这个函数是可以求导的，也就是求(x,y)(x,y)(x,y)这个坐标的斜率。 泰勒级数 由来 一个函数可以写成f(x)=∑i=0naixi=a0+a1x1+a2x2f(x)=\sum^n_{i=0}{a_ix^i}=a_0+a_1x_1+a_2x_2f(x)=∑i=0n​ai​xi=a0​+a1​x1​+a2​x2​ 在高阶导数的时候说过，如果两个函数每一阶导数都相等，那么&quot;理论上&quot;两个函数是相等的。 比如函数y=cos(x)y=cos(x)y=cos(x)，当x=0x=0x=0的时候，y=1y=1y=1 因为我们有cos′(x)=−sin(x)cos&#x27;(x)=-sin(x)cos′(x)=−sin(x)、cos′′(x)=−cos(x)cos&#x27;&#x27;(x)=-cos(x)cos′′(x)=−cos(x)、cos′′′(x)=sin(x)cos&#x27;&#x27;&#x27;(x)=sin(x)cos′′′(x)=sin(x)、cos′′′′(x)=cos(x)cos&#x27;&#x27;&#x27;&#x27;(x)=cos(x)cos′′′′(x)=cos(x) 此后就是−sin(x)-sin(x)−sin(x)、−cos(x)-cos(x)−cos(x)、sin(x)sin(x)sin(x)、cos(x)cos(x)cos(x)循环，求导次数xxx，其xmod 4=1230x \mod\ 4=1\,2\,3\,0xmod 4=1230的时候分别对应这四个。 cos(0)=1cos(0)=1cos(0)=1，f(x)=a0+∑i=1nai⋅0=a0=1f(x)=a_0+\sum_{i=1}^n{a_i\cdot0}=a_0=1f(x)=a0​+∑i=1n​ai​⋅0=a0​=1 cos′(0)=0cos&#x27;(0)=0cos′(0)=0，f′(x)=1⋅a1+∑i=2n(i−1)ai⋅0=1!⋅a1=0f&#x27;(x)=1\cdot a_1+\sum_{i=2}^n{(i-1)a_i\cdot0}=1!\cdot a_1=0f′(x)=1⋅a1​+∑i=2n​(i−1)ai​⋅0=1!⋅a1​=0 cos⁡′′(0)=−1\cos&#x27;&#x27;(0)=-1cos′′(0)=−1，同理f′′(x)=1⋅2⋅a2+∑i=3n(i−1)⋅(i−2)ai=2!⋅a2=−1f&#x27;&#x27;(x)=1\cdot2\cdot a_2+\sum_{i=3}^n{(i-1)\cdot(i-2)a_i}=2!\cdot a_2=-1f′′(x)=1⋅2⋅a2​+∑i=3n​(i−1)⋅(i−2)ai​=2!⋅a2​=−1 cos′′′(0)=0cos&#x27;&#x27;&#x27;(0)=0cos′′′(0)=0，f′′′(x)=1⋅2⋅3a3+∑i=4n(i−1)⋅(i−2)⋅(i−3)ai=3!⋅a3=0f&#x27;&#x27;&#x27;(x)=1\cdot2\cdot3 a_3+\sum_{i=4}^n{(i-1)\cdot(i-2)\cdot(i-3)a_i}=3!\cdot a_3=0f′′′(x)=1⋅2⋅3a3​+∑i=4n​(i−1)⋅(i−2)⋅(i−3)ai​=3!⋅a3​=0 cos′′′′(0)=1cos&#x27;&#x27;&#x27;&#x27;(0)=1cos′′′′(0)=1，f′′′′(x)=1⋅2⋅3⋅4a4+∑i=5n(i−1)⋅(i−2)⋅(i−3)⋅(i−4)ai=4!⋅a4=1f&#x27;&#x27;&#x27;&#x27;(x)=1\cdot2\cdot3\cdot4 a_4+\sum_{i=5}^n{(i-1)\cdot(i-2)\cdot(i-3)\cdot(i-4)a_i}=4!\cdot a_4=1f′′′′(x)=1⋅2⋅3⋅4a4​+∑i=5n​(i−1)⋅(i−2)⋅(i−3)⋅(i−4)ai​=4!⋅a4​=1 可以发现规律了，假设取了iii次导数，且有i=2ni=2ni=2n。 那么如果nnn是奇数有：i!⋅ai=−1⇒ai=−1i!i!\cdot a_i=-1\Rightarrow a_i=-\frac{1}{i!}i!⋅ai​=−1⇒ai​=−i!1​ 如果nnn是偶数有：i!⋅ai=1⇒ai=1i!i!\cdot a_i=1\Rightarrow a_i=\frac{1}{i!}i!⋅ai​=1⇒ai​=i!1​ 也就是cos(x)=1−x22!+x44!−x66!+x48!−…cos(x)=1-\frac{x^2}{2!}+\frac{x^4}{4!}-\frac{x^6}{6!}+\frac{x^4}{8!}-\dotscos(x)=1−2!x2​+4!x4​−6!x6​+8!x4​−… 同样的思路可以证明sin⁡(x)=∑i=2n+1,n∈N∞(−1)nxii!=x−x33!+x55!−x77!+…\sin(x)=\sum^{\infty}_{i=2n+1,n\in N}{(-1)^n\frac{x^i}{i!}}=x-\frac{x^3}{3!}+\frac{x^5}{5!}-\frac{x^7}{7!}+\dotssin(x)=∑i=2n+1,n∈N∞​(−1)ni!xi​=x−3!x3​+5!x5​−7!x7​+… 证明ex=…e^x=\dotsex=…比这更容易，根据定义(ex)′=ex(e^x)&#x27;=e^x(ex)′=ex，重复上述过程即可。 麦克劳林展开式 ex=∑i=0∞xii!=1+x11!+x22!+x33!+x44!+…e^x=\sum^\infty_{i=0}{\frac{x^i}{i!}}=1+\frac{x^1}{1!}+\frac{x^2}{2!}+\frac{x^3}{3!}+\frac{x^4}{4!}+\dotsex=∑i=0∞​i!xi​=1+1!x1​+2!x2​+3!x3​+4!x4​+… sin⁡(x)=∑i=2n+1,n∈N∞(−1)nxii!=x−x33!+x55!−x77!+…\sin(x)=\sum^{\infty}_{i=2n+1,n\in N}{(-1)^n\frac{x^i}{i!}}=x-\frac{x^3}{3!}+\frac{x^5}{5!}-\frac{x^7}{7!}+\dotssin(x)=∑i=2n+1,n∈N∞​(−1)ni!xi​=x−3!x3​+5!x5​−7!x7​+… cos⁡(x)=∑i=2n,n∈N∞(−1)nxii!=1−x22!+x44!−x66!+…\cos(x)=\sum^{\infty}_{i=2n,n\in N}(-1)^n\frac{x^i}{i!}=1-\frac{x^2}{2!}+\frac{x^4}{4!}-\frac{x^6}{6!}+\dotscos(x)=∑i=2n,n∈N∞​(−1)ni!xi​=1−2!x2​+4!x4​−6!x6​+… 本文正题 eix=1+(ix)11!+(ix)22!+(ix)33!+(ix)44!+(ix)55!=1+ix1!−x22!−ix33!+x44!+ix55!−…e^{ix}=1+\frac{(ix)^1}{1!}+\frac{(ix)^2}{2!}+\frac{(ix)^3}{3!}+\frac{(ix)^4}{4!}+\frac{(ix)^5}{5!}=1+\frac{ix}{1!}-\frac{x^2}{2!}-\frac{ix^3}{3!}+\frac{x^4}{4!}+\frac{ix^5}{5!}-\dotseix=1+1!(ix)1​+2!(ix)2​+3!(ix)3​+4!(ix)4​+5!(ix)5​=1+1!ix​−2!x2​−3!ix3​+4!x4​+5!ix5​−… 把带有iii的提出来有： eix=1−x22!+x44!−x66!+⋯+i(x−x33!+x55!−x77!)=cos(x)+i×sin(x)e^{ix}=1-\frac{x^2}{2!}+\frac{x^4}{4!}-\frac{x^6}{6!}+\dots+i(x-\frac{x^3}{3!}+\frac{x^5}{5!}-\frac{x^7}{7!})=cos(x)+i\times sin(x)eix=1−2!x2​+4!x4​−6!x6​+⋯+i(x−3!x3​+5!x5​−7!x7​)=cos(x)+i×sin(x) 当x=πx=\pix=π的时候 eiπ=cos⁡(π)+i×sin⁡(π)=−1e^{i\pi}=\cos(\pi)+i\times \sin(\pi)=-1eiπ=cos(π)+i×sin(π)=−1 所以eiπ+1=0e^{i\pi}+1=0eiπ+1=0]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欧拉公式]]></title>
    <url>%2Fpost%2F9401e9ac.html</url>
    <content type="text"><![CDATA[欧拉公式 前言 今天博主在b站上看完了一个视频。此视频介绍了欧拉从定义π\piπ、以欧拉命名、伯努利发明的数eee、sinsinsin和coscoscos以及eie^iei、eee的泰勒展开式以及虚数iii。 最近几天要学FFTFFTFFT，这是一篇学习笔记希望能以新的角度审视数学，有错误的话，感谢评论里指出。 前置知识 幂法则 如果f(x)=xnf(x)=x^nf(x)=xn，那么f′(x)=nxn−1f&#x27;(x)=nx^{n-1}f′(x)=nxn−1 证明 新的函数值是f(x+dx)=(x+dx)n=(x+dx)(x+dx)(x+dx)⋯(x+dx)f(x+\mathrm{d}x)=(x+\mathrm{d}x)^n=(x+\mathrm{d}x)(x+\mathrm{d}x)(x+\mathrm{d}x)\cdots(x+\mathrm{d}x)f(x+dx)=(x+dx)n=(x+dx)(x+dx)(x+dx)⋯(x+dx) 可以由二项式定理得到 (x+dx)n=∑i=0n(in)xn−i(dx)i=(0n)xn+(1n)xn−1dx+(2n)xn−2(dx)2⋯(x+\mathrm{d}x)^n=\sum^{n}_{i=0}\left(\begin{array}{c}i\\ n\end{array}\right)x^{n-i}(\mathrm{d}x)^i=\left(\begin{array}{c}0\\ n\end{array}\right)x^n+\left(\begin{array}{c}1\\ n\end{array}\right)x^{n-1}\mathrm{d}x+\left(\begin{array}{c}2\\ n\end{array}\right)x^{n-2}(\mathrm{d}x)^2\cdots (x+dx)n=i=0∑n​(in​)xn−i(dx)i=(0n​)xn+(1n​)xn−1dx+(2n​)xn−2(dx)2⋯ df=f(x+dx)−f(x)=xn−1dx+xn−2(dx)2⋯df=f(x+\mathrm{d}x)-f(x)=x^{n-1}\mathrm{d}x+x^{n-2}(\mathrm{d}x)^2\cdots df=f(x+dx)−f(x)=xn−1dx+xn−2(dx)2⋯ dfdx=xn−1+n(n−1)2xn−2dx+n(n−1)(n−2)6xn−2dx⋯\frac{df}{dx}=x^{n-1}+\frac{n(n-1)}{2}x^{n-2}dx+\frac{n(n-1)(n-2)}{6}x^{n-2}dx\cdots dxdf​=xn−1+2n(n−1)​xn−2dx+6n(n−1)(n−2)​xn−2dx⋯ 因为dxdxdx趋向000,所以可以忽略含有dxdxdx的项,dfdx=xn−1\frac{df}{dx}=x^{n-1}dxdf​=xn−1 加法则 两个函数f(x)f(x)f(x)、g(x)g(x)g(x)，那么(f(x)+g(x))′=f′(x)+g′(x)(f(x)+g(x))&#x27;=f&#x27;(x)+g&#x27;(x)(f(x)+g(x))′=f′(x)+g′(x) 积法则 两个函数f(x)f(x)f(x)、g(x)g(x)g(x)，那么(f(x)g(x))′=f(x)g′(x)+f′(x)g(x)(f(x)g(x))&#x27;=f(x)g&#x27;(x)+f&#x27;(x)g(x)(f(x)g(x))′=f(x)g′(x)+f′(x)g(x) 证明 由于相乘想到面积来可视化过程，设一个矩形长宽分别为f(x)f(x)f(x)、g(x)g(x)g(x)，设h(x)=(f(x)g(x))′h(x)=(f(x)g(x))&#x27;h(x)=(f(x)g(x))′ 如图所示： 显然增加的面积就是三块有颜色面积的小矩形，绿红黄他们的面积之和为： f(x)d(g(x))+g(x)d(f(x))+d(f(x))d(g(x))=h′(x)dx⇒f(x)\mathrm{d}(g(x))+g(x)\mathrm{d}(f(x))+\mathrm{d}(f(x))\mathrm{d}(g(x))=h&#x27;(x)\mathrm{d}x\Rightarrow f(x)d(g(x))+g(x)d(f(x))+d(f(x))d(g(x))=h′(x)dx⇒ f(x)g′(x)dx+g(x)f′(x)dx+g′(x)dxf′(x)dx=h′(x)dxf(x)g&#x27;(x)\mathrm{d}x+g(x)f&#x27;(x)\mathrm{d}x+g&#x27;(x)\mathrm{d}xf&#x27;(x)\mathrm{d}x=h&#x27;(x)\mathrm{d}x f(x)g′(x)dx+g(x)f′(x)dx+g′(x)dxf′(x)dx=h′(x)dx 那么h′(x)dx=f(x)g′(x)+g(x)f′(x)+g′(x)f′(x)dx\frac{h&#x27;(x)}{dx}=f(x)g&#x27;(x)+g(x)f&#x27;(x)+g&#x27;(x)f&#x27;(x)\mathrm{d}xdxh′(x)​=f(x)g′(x)+g(x)f′(x)+g′(x)f′(x)dx 发现尾项与dx\mathrm{d}xdx有关，当dx\mathrm{d}xdx趋向000的时候可以忽略。 链式法则 两个函数f(x)f(x)f(x)、g(x)g(x)g(x)，那么f′(g(x))=f′(g(x))g′(x)f&#x27;(g(x))=f&#x27;(g(x))g&#x27;(x)f′(g(x))=f′(g(x))g′(x)，也就是dfdx=dfdgdgdx\frac{\mathrm{d}f}{\mathrm{d}x}=\frac{\mathrm{d}f}{\mathrm{d}g}\frac{\mathrm{d}g}{\mathrm{d}x}dxdf​=dgdf​dxdg​ 证明 当xxx变化量为dxdxdx的时候,ggg函数变化量是d(g(x))\mathrm{d}(g(x))d(g(x))。 fff函数的变化量为： d(f(g(x)))=f′(g(x))d(g(x))=f′(g(x))g′(x)dx⇒d(f(g(x))dx=f′(g(x))g′(x)\mathrm{d}(f(g(x)))=f&#x27;(g(x))\mathrm{d}(g(x))=f&#x27;(g(x))g&#x27;(x)\mathrm{d}x\Rightarrow \frac{\mathrm{d}(f(g(x))}{\mathrm{d}x}=f&#x27;(g(x))g&#x27;(x) d(f(g(x)))=f′(g(x))d(g(x))=f′(g(x))g′(x)dx⇒dxd(f(g(x))​=f′(g(x))g′(x) 最后一步是由导数的定义得来的。 通过幂法则、链式法则推到商法则 三角函数的导数 sin⁡′(x)=cos(x)\sin&#x27;(x)=cos(x)sin′(x)=cos(x) cos⁡′(x)=−sin(x)\cos&#x27;(x)=-sin(x)cos′(x)=−sin(x) 证明 高阶导数 f(n)(x)f^{(n)}(x)f(n)(x)指的是f(x)f(x)f(x)的nnn阶导数。我自己的理解：描述f(x)f(x)f(x)的变化函数是f′(x)f&#x27;(x)f′(x)，描述f′(x)f&#x27;(x)f′(x)的变化函数f′′(x)f&#x27;&#x27;(x)f′′(x)，也就是f(n)f^{(n)}f(n)的变化受到f(n+1)f^{(n+1)}f(n+1)的控制，如果控制f1f^1f1、f2f^2f2···他们的函数都相等，那么&quot;理论上&quot;这两个函数是相等的。下面泰勒级数就用到这个思想。 拓展（无关本文) 指数函数求导 尝试求导 M(t)=2tM(t)=2^tM(t)=2t dMdt=2t+dt−2tdt=2t(2dt−1dt)⎵dt→0\frac{\mathrm{d}M}{\mathrm{d}t}=\frac{2^{t+\mathrm{d}t}-2^t}{\mathrm{d}t}=2^t\underbrace{(\frac{2^{\mathrm{d}t}-1}{\mathrm{d}t})}_{dt\to0} dtdM​=dt2t+dt−2t​=2tdt→0(dt2dt−1​)​​ 2dt−1dt\frac{2^{\mathrm{d}t}-1}{\mathrm{d}t}dt2dt−1​趋向于一个常数0.69314718056⋯0.69314718056\cdots0.69314718056⋯ 同样函数M(t)=3tM(t)=3^tM(t)=3t同样的方法，后半部分将趋向于1.09861228867⋯1.09861228867\cdots1.09861228867⋯ M(t)=8t→2.07944154168⋯M(t)=8^t\to 2.07944154168\cdotsM(t)=8t→2.07944154168⋯ 1.09861228867⋯×3=2.07944154168⋯1.09861228867\cdots{\times3}=2.07944154168\cdots1.09861228867⋯×3=2.07944154168⋯ 从指数上8=238=2^38=23，说明这个常数是对于对某个数求对数函数得到的。 有没有哪个底数能是的这个系数为111呢？ 即(at)′=at(a^t)&#x27;=a^t(at)′=at？ e的出现 这个底数就是e=2.71828⋯e=2.71828\cdotse=2.71828⋯ a^x的导数 由上面得到(ax)′=axln⁡(a)(a^x)&#x27;=a^x\ln(a)(ax)′=axln(a) d(ect)dt=cect\frac{d(e^{ct})}{\mathrm{d}t}=ce^{ct}dtd(ect)​=cect，ccc是常数，由复合函数求导。 所有指数函数aaa写作eln⁡(2)e^{\ln(2)}eln(2) 代入上式得到：ax=eln⁡(a)ta^x=e^{\ln(a)t}ax=eln(a)t 隐函数求导 圆的方程式x2+y2=rx^2+y^2=rx2+y2=r，这很显然，如果我们要对它求导怎么办？此时输入一个xxx不一定输出一个yyy。很显然这个函数是可以求导的，也就是求(x,y)(x,y)(x,y)这个坐标的斜率。 泰勒级数 由来 一个函数可以写成f(x)=∑i=0naixi=a0+a1x1+a2x2+⋯f(x)=\sum^n_{i=0}{a_ix^i}=a_0+a_1x_1+a_2x_2+\cdotsf(x)=∑i=0n​ai​xi=a0​+a1​x1​+a2​x2​+⋯ 在高阶导数的时候说过，如果两个函数每一阶导数都相等，那么&quot;理论上&quot;两个函数是相等的。 因为我们有cos′(x)=−sin(x)cos&#x27;(x)=-sin(x)cos′(x)=−sin(x)、cos′′(x)=−cos(x)cos&#x27;&#x27;(x)=-cos(x)cos′′(x)=−cos(x)、cos′′′(x)=sin(x)cos&#x27;&#x27;&#x27;(x)=sin(x)cos′′′(x)=sin(x)、cos′′′′(x)=cos(x)cos&#x27;&#x27;&#x27;&#x27;(x)=cos(x)cos′′′′(x)=cos(x) 此后就是−sin(x)-sin(x)−sin(x)、−cos(x)-cos(x)−cos(x)、sin(x)sin(x)sin(x)、cos(x)cos(x)cos(x)循环，求导次数xxx，其xmod 4=1x \mod\ 4=1xmod 4=1,222,333,000的时候分别对应这四个。 cos(0)=1⇒f(x)=a0+∑i=1nai⋅0=a0=1cos(0)=1\Rightarrow f(x)=a_0+\sum_{i=1}^n{a_i\cdot0}=a_0=1cos(0)=1⇒f(x)=a0​+∑i=1n​ai​⋅0=a0​=1 cos′(0)=0⇒f′(x)=1⋅a1+∑i=2n(i−1)ai⋅0=1!⋅a1=0cos&#x27;(0)=0\Rightarrow f&#x27;(x)=1\cdot a_1+\sum_{i=2}^n{(i-1)a_i\cdot0}=1!\cdot a_1=0cos′(0)=0⇒f′(x)=1⋅a1​+∑i=2n​(i−1)ai​⋅0=1!⋅a1​=0 cos⁡′′(0)=−1⇒f′′(x)=1⋅2⋅a2+∑i=3n(i−1)⋅(i−2)ai=2!⋅a2=−1\cos&#x27;&#x27;(0)=-1\Rightarrow f&#x27;&#x27;(x)=1\cdot2\cdot a_2+\sum_{i=3}^n{(i-1)\cdot(i-2)a_i}=2!\cdot a_2=-1cos′′(0)=−1⇒f′′(x)=1⋅2⋅a2​+∑i=3n​(i−1)⋅(i−2)ai​=2!⋅a2​=−1 cos′′′(0)=0⇒f′′′(x)=1⋅2⋅3a3+∑i=4n(i−1)⋅(i−2)⋅(i−3)ai=3!⋅a3=0cos&#x27;&#x27;&#x27;(0)=0\Rightarrow f&#x27;&#x27;&#x27;(x)=1\cdot2\cdot3 a_3+\sum_{i=4}^n{(i-1)\cdot(i-2)\cdot(i-3)a_i}=3!\cdot a_3=0cos′′′(0)=0⇒f′′′(x)=1⋅2⋅3a3​+∑i=4n​(i−1)⋅(i−2)⋅(i−3)ai​=3!⋅a3​=0 cos′′′′(0)=1⇒f′′′′(x)=1⋅2⋅3⋅4a4+∑i=5n(i−1)⋅(i−2)⋅(i−3)⋅(i−4)ai=4!⋅a4=1cos&#x27;&#x27;&#x27;&#x27;(0)=1\Rightarrow f&#x27;&#x27;&#x27;&#x27;(x)=1\cdot2\cdot3\cdot4 a_4+\sum_{i=5}^n{(i-1)\cdot(i-2)\cdot(i-3)\cdot(i-4)a_i}=4!\cdot a_4=1cos′′′′(0)=1⇒f′′′′(x)=1⋅2⋅3⋅4a4​+∑i=5n​(i−1)⋅(i−2)⋅(i−3)⋅(i−4)ai​=4!⋅a4​=1 可以发现规律了，假设取了iii次导数，且有i=2ni=2ni=2n。 nnn是奇数有：i!⋅ai=−1⇒ai=−1i!i!\cdot a_i=-1\Rightarrow a_i=-\frac{1}{i!}i!⋅ai​=−1⇒ai​=−i!1​ nnn是偶数有：i!⋅ai=1⇒ai=1i!i!\cdot a_i=1\Rightarrow a_i=\frac{1}{i!}i!⋅ai​=1⇒ai​=i!1​ 也就是cos(x)=1−x22!+x44!−x66!+x48!−⋯cos(x)=1-\frac{x^2}{2!}+\frac{x^4}{4!}-\frac{x^6}{6!}+\frac{x^4}{8!}-\cdotscos(x)=1−2!x2​+4!x4​−6!x6​+8!x4​−⋯ 同样的思路可以证明sin⁡(x)=∑i=2n+1,n∈N∞(−1)nxii!=x−x33!+x55!−x77!+⋯\sin(x)=\sum^{\infty}_{i=2n+1,n\in N}{(-1)^n\frac{x^i}{i!}}=x-\frac{x^3}{3!}+\frac{x^5}{5!}-\frac{x^7}{7!}+\cdotssin(x)=∑i=2n+1,n∈N∞​(−1)ni!xi​=x−3!x3​+5!x5​−7!x7​+⋯ 证明ex=⋯e^x=\cdotsex=⋯比这更容易，根据定义(ex)′=ex(e^x)&#x27;=e^x(ex)′=ex，重复上述过程即可。 麦克劳林展开式 ex=∑i=0∞xii!=1+x11!+x22!+x33!+x44!+⋯e^x=\sum^\infty_{i=0}{\frac{x^i}{i!}}=1+\frac{x^1}{1!}+\frac{x^2}{2!}+\frac{x^3}{3!}+\frac{x^4}{4!}+\cdotsex=∑i=0∞​i!xi​=1+1!x1​+2!x2​+3!x3​+4!x4​+⋯ sin⁡(x)=∑i=2n+1,n∈N∞(−1)nxii!=x−x33!+x55!−x77!+⋯\sin(x)=\sum^{\infty}_{i=2n+1,n\in N}{(-1)^n\frac{x^i}{i!}}=x-\frac{x^3}{3!}+\frac{x^5}{5!}-\frac{x^7}{7!}+\cdotssin(x)=∑i=2n+1,n∈N∞​(−1)ni!xi​=x−3!x3​+5!x5​−7!x7​+⋯ cos⁡(x)=∑i=2n,n∈N∞(−1)nxii!=1−x22!+x44!−x66!+⋯\cos(x)=\sum^{\infty}_{i=2n,n\in N}(-1)^n\frac{x^i}{i!}=1-\frac{x^2}{2!}+\frac{x^4}{4!}-\frac{x^6}{6!}+\cdotscos(x)=∑i=2n,n∈N∞​(−1)ni!xi​=1−2!x2​+4!x4​−6!x6​+⋯ 本文正题 eix=1+(ix)11!+(ix)22!+(ix)33!+(ix)44!+(ix)55!=1+ix1!−x22!−ix33!+x44!+ix55!−⋯e^{ix}=1+\frac{(ix)^1}{1!}+\frac{(ix)^2}{2!}+\frac{(ix)^3}{3!}+\frac{(ix)^4}{4!}+\frac{(ix)^5}{5!}=1+\frac{ix}{1!}-\frac{x^2}{2!}-\frac{ix^3}{3!}+\frac{x^4}{4!}+\frac{ix^5}{5!}-\cdotseix=1+1!(ix)1​+2!(ix)2​+3!(ix)3​+4!(ix)4​+5!(ix)5​=1+1!ix​−2!x2​−3!ix3​+4!x4​+5!ix5​−⋯ 把带有iii的提出来有： eix=1−x22!+x44!−x66!+⋯+i(x−x33!+x55!−x77!)=cos(x)+i×sin(x)e^{ix}=1-\frac{x^2}{2!}+\frac{x^4}{4!}-\frac{x^6}{6!}+\cdots+i(x-\frac{x^3}{3!}+\frac{x^5}{5!}-\frac{x^7}{7!})=cos(x)+i\times sin(x)eix=1−2!x2​+4!x4​−6!x6​+⋯+i(x−3!x3​+5!x5​−7!x7​)=cos(x)+i×sin(x) 当x=πx=\pix=π的时候 eiπ=cos⁡(π)+i×sin⁡(π)=−1e^{i\pi}=\cos(\pi)+i\times \sin(\pi)=-1eiπ=cos(π)+i×sin(π)=−1 所以eiπ+1=0e^{i\pi}+1=0eiπ+1=0]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>欧拉公式</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
</search>
